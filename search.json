[{"title":"BST到AVL再到红黑树","url":"/2021/01/19/BST%E5%88%B0AVL%E5%86%8D%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/","content":"本篇介绍了从二叉搜索树到平衡二叉树，最后演变成红黑树的全过程，循序渐进的理解这几种数据结构的优化演变过程\n\n二叉搜索树特点二叉树的一个重要应用就是用于解决查找问题，二叉搜索树（Binary Search Tree）是满足这样一个条件的二叉树：对于树中的每个节点X，它的左子树中所有关键字值小于X的关键字值，而它的右子树中所有关键字值大于X的关键字值\n\n复杂度分析查找\n例如要查找数值7，查找的过程如下：\n\n7与根节点6比较，7 &gt; 6，进入右子树\n7与根节点8比较，7 &lt; 8，进入左子树\n7与根节点7比较，7 == 7，查找成功\n\n插入\n插入操作类似，每一层只需要比较一个节点\n分析\n通过上述过程的分析，不难发现二叉搜索树的时间复杂度依赖于树的深度，对于节点数值分布均匀的树来说，深度是logn数量级\n\n对比有序数组分析二叉搜索树的操作过程，很容易联想到二分操作。那么对一个有序的数组进行二分操作，与二叉搜索树是否相同呢？\n答案显然是并不相同，但二者存在相似性。对一个有序数组进行二分查找时，也是每次比较中间元素（相当于根节点），大于中间元素值则递归去查找右子表（对应于进入右子树），直至查找结束。故有序数组的二分查找，时间复杂度也是O(logn)\n区别在于插入和删除操作，有序数组找到插入点和删除点后，需要进行元素的移动操作。查找插入位置用二分查找是O(logn)，将插入位置后的元素全部后移一位，时间复杂度O(n)，所以总的时间复杂度是O(n)（ O(logn)+O(n)=O(n) ）。删除操作类似，只是删除位置后所有元素前移一位，时间复杂度也为O(n)\nBST的缺陷由上图给出的二叉搜索树的复杂度，最坏情况下的操作复杂度都为O(n)，这是为什么呢？\n考虑一种特殊情况，插入的数据是有序的，此时二叉搜索树退化成链表\n\nAVL树自平衡二叉查找树（Adelson-Velsky and Landis Tree）\n上面我们知道了二叉搜索树的一个缺陷是，最坏情况下的复杂度会退化成O(n)，这点也是源于BST的时间复杂度依赖于树的深度\n那么就可以想到通过控制树的深度去优化算法，于是AVL树诞生了\n特点AVL树是一种特殊的二叉搜索树，在AVL树中，任一节点对应的两棵子树的最大高度差为1（这种“平衡”的条件实则是有些苛刻的…）\n复杂度分析类似于二叉搜索树，不同的是由于AVL树对深度的自平衡控制，使得AVL树的查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)\n\n左旋右旋节点的平衡因子是它的左子树的高度减去它的右子树的高度，带有平衡因子1、0或 -1的节点被认为是平衡的。由于平衡条件并不总是满足的，为了维持AVL树的平衡，需要进行一次或多次旋转操作\n\n分析上图：（依自己理解所表述）\n\n左左情况：失衡的根节点沿两次左子树方向到达导致失衡的最小子树根节点处，需要进行一次右旋\n右旋时三个节点位于一条左斜的直线上（5，3，2），以中间节点（3）为支点，先将中间节点（3）的右子树（B）无视，将失衡根节点（5）右旋到中间节点（3）的右子树上，同时保留失衡节点（5）的右子树（A）情况，最后将中间节点（3）的右子树（B）插入到正确位置（由于B比3大比5小，所以插在5的左子树上），平衡，完毕\n\n右右情况：失衡的根节点沿两次右子树方向到达导致失衡的最小子树根节点处，需要进行一次左旋\n左旋时三个节点位于一条右斜的直线上（3，5，7），以中间节点（5）为支点，先将中间节点（5）的左子树（B）无视，将失衡根节点（3）左旋到中间节点（5）的左子树上，同时保留失衡节点（3）的左子树（A）情况，最后将中间节点（5）的左子树（B）插入到正确位置（由于B比3大比5小，所以插在3的右子树上），平衡，完毕\n\n左右情况：失衡的根节点沿一次左子树方向和一次右子树方向到达导致失衡的最小子树根节点处，需要先进行一次左旋，转变成左左情况，再进行一次右旋\n对于左右情况的左旋，是将失衡节点（5）的左子树（也可理解为失衡部分）根节点（3）进行左旋，旋转的支点是“左右”中的“右”（4），旋转操作过程类比上述过程，不再赘述。一次左旋后，整体的树变成了左左情况，再相应进行一次右旋即可实现平衡\n\n右左情况：失衡的根节点沿一次右子树方向和一次左子树方向到达导致失衡的最小子树根节点处，需要先进行一次右旋，转变成右右情况，再进行一次左旋\n对于右左情况的右旋，是将失衡节点（3）的右子树（也可理解为失衡部分）根节点（5）进行右旋，旋转的支点是“右左”中的“左”（4），旋转操作过程类比上述过程，不再赘述。一次右旋后，整体的树变成了右右情况，再相应进行一次左旋即可实现平衡\n\n\nAVL的缺陷AVL树确实能够使查找插入和删除的时间复杂度在平均和最坏的情况下都为O(logn)，但是AVL树所维持的平衡条件是每个节点的左右子树深度差≤1，这个条件是相对苛刻的，这意味着在程序实际执行过程中可能会出现大量的左旋右旋操作来维持平衡，旋转操作是需要消耗时间的，从而降低了效率\n红黑树红黑树（Red–black tree）是一种自平衡二叉查找树，红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入删除操作时少量的旋转操作，整体来说性能要优于AVL树\n特点红黑树是每个节点都带有颜色属性的自平衡二叉查找树，除了具有BST的一般特性外，红黑树还具有如下五个重要的特性：\n\n节点要么是红色要么是黑色\n根节点是黑色\n所有叶子都是黑色（特别注意的是，红黑树中的叶子是NIL节点）\n每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）\n从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点\n\n\n分析理解对于红黑树上述的五条重要特性，前面几条可能很好理解，但对于第五条可能会觉得有点懵(￣▽￣)”\n下面就来重点理解一下“从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点”这条特性意味着什么\n考虑两种极端情况，一种极端情况是没有红节点，两条路径上都是黑节点（这是允许的），那么意味着两条路径上的节点数相等\n\n另一种极端情况是，一条路径上没有红节点，另一条路径上尽可能多的出现红节点。而又根据性质4，从每个叶子到根的所有路径上不能有两个连续的红色节点，意味着红黑树中最长路径就是一条红黑交替的路径，这种情况两边节点数相差一倍\n\n由此，我们不难发现：红黑树的平衡是将左右子树的深度差维持在一倍以内\n复杂度分析\nAVL树由于将左右子树的深差控制在1以内，所以树的高度也控制在logn数量级，这使得AVL树查找插入和删除的时间复杂度在平均和最坏的情况下都为O(logn)。但是为什么红黑树将左右子树的深度差控制在一倍以内，也能实现平均和最坏情况都是O(logn)的复杂度呢？\n简单分析如下：\n\nn：红黑树的节点总数；n(r)：红节点总数；n(b)：黑节点总数\nn = n(r) + n(b)\n\n如果将红黑树中的红节点盖住不看，那么整棵树就是一颗AVL树，深度为logn(b)。再考虑红节点的加入对红黑树的影响，最差的情况下红黑交替出现，也就是说整棵树的深度会变成原来的两倍，即O(2*logn(b))。但是，时间复杂度讨论的是n（节点总数）。根据性质4，从根到叶子的任何路径上至少有一半的节点是黑色，由于时间复杂度讨论的是数量级，所以常量不影响\n\nO(2*log_2n(b)) -> O(2*log_2\\frac{n}{2}) -> O(log_2\\frac{n}{2}) -> O(log_2n-1) -> O(log_2n)当然，上述只是简单的分析，需要严格证明红黑树的时间复杂度为O(logn)的话，还需要利用数学归纳法去证明，证明过程中还可以引申出一条定理：一棵含有n个节点的红黑树的高度至多为2log(n+1)\n操作由于红黑树是一种特殊的二叉搜索树，对于只读操作（比如：查找），与一般的二叉搜索树操作相同。但是插入和删除操作需要进行调整，以使得其继续符合红黑树的特性。红黑树的插入和删除操作很复杂，但是操作时间仍可以保持为O(logn)\n插入\n\n\n\n\n父节点\n叔节点\n类型\n操作\n\n\n\n\n黑\n—\n—\n无需操作\n\n\n红\n红\n—\n父叔都变黑，祖父变红。祖父变成当前节点，递归这个规则\n\n\n红\n黑\n左左\n右旋 + 变色\n\n\n红\n黑\n右右\n左旋 + 变色\n\n\n红\n黑\n左右\n先左旋，再右旋 + 变色\n\n\n红\n黑\n右左\n先右旋，再左旋 + 变色\n\n\n\n\n删除\n操作较复杂，暂不展开叙述…\n可视化演示https://www.cs.usfca.edu/~galles/visualization/RedBlack.html\n总结普通的二叉搜索树存在不平衡的问题，可能会导致在最坏的情况下退化成链表，从而使操作的时间复杂度由O(logn)退化成O(n)。AVL树解决了这一问题，通过旋转操作使树达到自平衡，从而保证了即使在最坏的情况下，操作的时间复杂度也能维持在O(logn)。但是AVL树维护平衡也需要很大的代价，苛刻的平衡条件（深差≤1）使得插入和删除操作可能需要大量频繁的旋转操作来调整树结构，这降低了效率。于是红黑树诞生了，它相当于一种折中的二叉搜索树，在不加限制的不平衡与苛刻的平衡之间维持了一种相对宽松的平衡（深差一倍以内），牺牲了部分平衡性以换来插入删除操作时较AVL更少量的旋转操作。事实证明，这种设计使得红黑树的整体性能要优于AVL树\nReferenceshttps://www.bilibili.com/video/BV1Pp4y1D7u1\nhttps://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91\n","categories":["数据结构"],"tags":["二叉树","红黑树"]},{"title":"Collections类","url":"/2021/02/17/Collections%E7%B1%BB/","content":"Collections是JDK提供的一个工具类，本篇介绍了Collections类的常用方法\n\n官方文档\nThis class consists exclusively of static methods that operate on or return collections. It contains polymorphic algorithms that operate on collections, “wrappers”, which return a new collection backed by a specified collection, and a few other odds and ends.\nThe methods of this class all throw a NullPointerException if the collections or class objects provided to them are null.\n\n翻译：\n\n此类仅包含对集合进行操作或返回集合的静态方法。它包含对集合进行操作的多态算法，“包装器”，该包装器返回由指定集合支持的新集合，以及其他一些零碎的结局。\n如果提供给它们的集合或类对象为null，则此类的所有方法都将引发NullPointerException。\n\nCollections是JDK提供的一个工具类，位于java.util包下，它提供的方法都是静态的，能更方便的操作各种集合\n下面介绍一些Collections类常用的方法\n常用方法空集合\nList&lt;T&gt; emptyList()    创建空List\n\nMap&lt;K, V&gt; emptyMap()    创建空Map\n\nSet&lt;T&gt; emptySet()    创建空Set\n\n\n注意：这些方法创建的空集合都是不可变集合，无法向其中添加或删除元素\n补充：利用集合接口提供的of(T...)方法创建空集合，与此方法等效\nList&lt;String&gt; list1 = List.of();//等价于List&lt;String&gt; list2 = Collections.emptyList();\n单元素集合\nList&lt;T&gt; singletonList(T o)    创建单元素List\n\nMap&lt;K, V&gt; singletonMap(K key, V value)    创建单元素Map\n\nSet&lt;T&gt; singleton(T o)    创建单元素Set\n\n\n注意：这些方法创建的单元素集合也都是不可变集合，无法向其中添加或删除元素\n补充：利用集合接口提供的of(T...)方法创建单元素集合，与此方法等效\nList&lt;String&gt; list1 = List.of(&quot;apple&quot;);//等价于List&lt;String&gt; list2 = Collections.singletonList(&quot;apple&quot;);\n集合接口提供的of(T...)方法，可创建任意个元素的集合\n不可变集合\nList&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)    将可变的List封装成不可变的List\nMap&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)    将可变的Map封装成不可变的Map\nSet&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)    将可变的Set封装成不可变的Set\n\n排序\nCollections.sort(List list)    自然排序（升序）\nCollections.sort(List list, Comparator c)    自定义排序\n\nCollections.reverse(List list)    次序反转\n\nCollections.swap(List list, int i, int j)    根据下标交换\nCollections.shuffle(List list)    随机排序\nCollections.rotate(List list, int distance)    将指定列表中的元素旋转指定的距离。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面\n\n查找\nCollections.binarySearch(List list, Object key)    二分查找，传入的List必须有序\nCollections.max(Collection coll)    根据自然排序，返回最大的元素\n\nCollections.max(Collection coll, Comparator c)    根据自定义排序，返回最大的元素\n\nCollections.min(Collection coll)    根据自然排序，返回最小的元素\n\nCollections.min(Collection coll, Comparator c)    根据自定义排序，返回最小的元素\n\nCollections.frequency(Collection c, Object o)    统计元素出现的次数\n\n\n替换\nCollections.replaceAll(List list, Object oldVal, Object newVal)    用新元素替换旧元素\nCollections.fill(List list, Object obj)    用指定的元素替代集合中的所有元素\n\n同步\nList&lt;T&gt; synchronizedList(List&lt;T&gt; list)    将线程不安全的List变为线程安全的List\n\nMap&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)    将线程不安全的Map变为线程安全的Map\n\nSet&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)    将线程不安全的Set变为线程安全的Set\n\n\n注意：从Java 5开始，引入了更高效的并发集合类，上述方法效率低下，不推荐使用\nReferenceshttps://www.liaoxuefeng.com/wiki/1252599548343744/1299919855943714\nhttps://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_15-collections-%e5%b7%a5%e5%85%b7%e7%b1%bb\n","categories":["Java"],"tags":["集合框架"]},{"title":"Comparable与Comparator","url":"/2021/02/17/Comparable%E4%B8%8EComparator/","content":"Java中提供了两个接口来通过类的数据成员对对象进行比较排序，一个是Comparable，另一个是Comparator\n\nComparable包：java.lang.Comparable\n排序方法：compareTo(T o)\n官方文档\nThis interface imposes a total ordering on the objects of each class that implements it. This ordering is referred to as the class’s natural ordering, and the class’s compareTo method is referred to as its natural comparison method.\nLists (and arrays) of objects that implement this interface can be sorted automatically by Collections.sort (and Arrays.sort). Objects that implement this interface can be used as keys in a sorted map or as elements in a sorted set, without the need to specify a comparator.\nThe natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo(e2) == 0 has the same boolean value as e1.equals(e2) for every e1 and e2 of class C. Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.\nIt is strongly recommended (though not required) that natural orderings be consistent with equals. This is so because sorted sets (and sorted maps) without explicit comparators behave “strangely” when they are used with elements (or keys) whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates the general contract for set (or map), which is defined in terms of the equals method.\n\n翻译：\n\n此接口对实现该接口的每个类的对象强加了总体排序。此排序称为类的自然排序，而该类的compareTo方法被称为其自然比较方法。\n实现此接口的对象的列表（和数组）可以由Collections.sort（和Arrays.sort）自动排序。实现此接口的对象可以用作sorted map中的键，也可以用作sorted set中的元素，而无需指定比较器。\n当且仅当e1.compareTo（e2）== 0对于C类的每个e1和e2具有与e1.equals（e2）相同的布尔值时，才可以认为C类的自然排序与equals一致。 null不是任何类的实例，即使e.equals（null）返回false，e.compareTo（null）也应引发NullPointerException。\n强烈建议（尽管不是必需的）自然顺序应与equals保持一致。之所以如此，是因为没有显式比较器的sorted sets（和sorted maps）在与自然排序与equals不一致的元素（或键）一起使用时，表现为“奇怪”。特别是，这样的sorted set（或sorted map）违反了根据equals方法定义的set（或map）总协定。\n\ncompareTo方法\nCompares this object with the specified object for order.  Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.\n\n将此对象与指定对象进行比较，当此对象小于、等于或大于指定的对象时，相应的返回负整数、零或正整数\n使用案例Book类：\npackage collection;public class Book implements Comparable&lt;Book&gt; &#123;    private String name;    private double price;    public Book(String name, double price) &#123;        this.name = name;        this.price = price;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public double getPrice() &#123;        return price;    &#125;    public void setPrice(double price) &#123;        this.price = price;    &#125;    //重写compareTo方法，实现按书本的价格排序    @Override    public int compareTo(Book o) &#123;        return (int) (this.price - o.price);    &#125;    @Override    public String toString() &#123;        return &quot;Book&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, price=&quot; + price +                &#x27;&#125;&#x27;;    &#125;&#125;\n测试类：\npackage collection;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;public class Main &#123;    public static void main(String[] args) &#123;        ArrayList&lt;Book&gt; bookList = new ArrayList&lt;Book&gt;();        bookList.add(new Book(&quot;《网络是怎样连接的》&quot;, 49.00));        bookList.add(new Book(&quot;《剑指Offer》&quot;, 65.00));        bookList.add(new Book(&quot;《编码》&quot;, 59.00));        //ArrayList默认的遍历顺序是元素的添加顺序        for (Book book : bookList) &#123;            System.out.println(book.toString());        &#125;        System.out.println(&quot;-------------------------------------------&quot;);        //调用Collections.sort()方法，对bookList中的元素按重写后的compareTo方法排序        Collections.sort(bookList);        //再次遍历，结果按照书本的价格从小到大排序        for (Book book : bookList) &#123;            System.out.println(book.toString());        &#125;    &#125;&#125;\n运行结果：\n\n特别的，实现此接口的对象可以用作sorted map中的键，也可以用作sorted set中的元素，而无需指定比较器\n这也进一步理解了为什么TreeMap、TreeSet实现按Key排序时，需要Key必须实现Comparable接口\nTreeSet&lt;Book&gt; bookTreeSet = new TreeSet&lt;Book&gt;();bookTreeSet.add(new Book(&quot;《网络是怎样连接的》&quot;, 49.00));bookTreeSet.add(new Book(&quot;《剑指Offer》&quot;, 65.00));bookTreeSet.add(new Book(&quot;《编码》&quot;, 59.00));//实现此接口的对象可以用作sorted map中的键，也可以用作sorted set中的元素，而无需指定比较器//所以，对于实现了SortedSet接口的TreeSet来说，无需指定比较器即可自动实现排序for (Book book : bookTreeSet) &#123;    System.out.println(book.toString());&#125;System.out.println(&quot;-------------------------------------------&quot;);//同理，对于实现了SortedMap接口的TreeMap来说，亦是如此TreeMap&lt;Book, Integer&gt; bookTreeMap = new TreeMap&lt;Book, Integer&gt;();bookTreeMap.put(new Book(&quot;《网络是怎样连接的》&quot;, 49.00), 1);bookTreeMap.put(new Book(&quot;《剑指Offer》&quot;, 65.00), 2);bookTreeMap.put(new Book(&quot;《编码》&quot;, 59.00), 3);for (Book book : bookTreeMap.keySet()) &#123;    System.out.println(book.toString());&#125;\nComparator包：java.util.Comparator\n排序方法：compare(T o1,T o2)\n官方文档\nA comparison function, which imposes a total ordering on some collection of objects. Comparators can be passed to a sort method (such as Collections.sort or Arrays.sort) to allow precise control over the sort order. Comparators can also be used to control the order of certain data structures (such as sorted sets or sorted maps), or to provide an ordering for collections of objects that don’t have a natural ordering.\nThe ordering imposed by a comparator c on a set of elements S is said to be consistent with equals if and only if c.compare(e1, e2)==0 has the same boolean value as e1.equals(e2) for every e1 and e2 in S.\nCaution should be exercised when using a comparator capable of imposing an ordering inconsistent with equals to order a sorted set (or sorted map). Suppose a sorted set (or sorted map) with an explicit comparator c is used with elements (or keys) drawn from a set S. If the ordering imposed by c on S is inconsistent with equals, the sorted set (or sorted map) will behave “strangely.” In particular the sorted set (or sorted map) will violate the general contract for set (or map), which is defined in terms of equals.\nNote: It is generally a good idea for comparators to also implement java.io.Serializable, as they may be used as ordering methods in serializable data structures (like TreeSet, TreeMap). In order for the data structure to serialize successfully, the comparator (if provided) must implement Serializable.\n\n翻译：\n\n一个强行对某些对象集合施加总体排序的比较函数。可以将比较器传递给排序方法（例如Collections.sort或Arrays.sort），以实现对排序顺序的精确控制。比较器还可以用于控制某些数据结构（例如sorted sets或sorted maps）的顺序，或为没有自然顺序的对象集合提供排序。\n当且仅当对于集合S中的每一个e1和e2，都有c.compare(e1, e2)==0的布尔值与e1.equals(e2)的布尔值相等时，才认为比较器c对一组元素S施加的排序被认为与equals一致。\n当使用具有与equals不一致的强行排序能力的Comparator对sorted set（或sorted map）进行排序时，应谨慎行事。假设带有显式比较器c的sorted set（或sorted map）与从集合S提取的元素（或键）一起使用。如果c对S施加的排序与equals不一致，则sorted set（或sorted map）将表现“奇怪”。特别是，sorted set（或sorted map）将违反用根据equals定义的set（或map）的一般约定。\n注意：比较器通常也可以实现java.io.Serializable，这是一个好主意，因为它们可用作可序列化数据结构（如TreeSet，TreeMap）中的排序方法。 为了使数据结构成功序列化，比较器（如果提供）必须实现Serializable。\n\ncompare方法\nCompares its two arguments for order.  Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.\n\n比较其两个参数的顺序，当第一个参数小于、等于或大于第二个参数时，相应的返回负整数、零或正整数\n使用案例Book类：\npackage collection;public class Book &#123;    private String name;    private double price;    public Book(String name, double price) &#123;        this.name = name;        this.price = price;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public double getPrice() &#123;        return price;    &#125;    public void setPrice(double price) &#123;        this.price = price;    &#125;    @Override    public String toString() &#123;        return &quot;Book&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, price=&quot; + price +                &#x27;&#125;&#x27;;    &#125;&#125;\n排序类：\npackage collection;import java.util.Comparator;//定义一个排序类，让其实现Comparator接口class BookComparator implements Comparator&lt;Book&gt; &#123;    //需要重写compare方法    @Override    public int compare(Book o1, Book o2) &#123;        return (int) (o1.getPrice() - o2.getPrice());    &#125;&#125;\n测试类：\npackage collection;import sun.reflect.generics.tree.Tree;import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        ArrayList&lt;Book&gt; bookArrayList = new ArrayList&lt;Book&gt;();        bookArrayList.add(new Book(&quot;《网络是怎样连接的》&quot;, 49.00));        bookArrayList.add(new Book(&quot;《剑指Offer》&quot;, 65.00));        bookArrayList.add(new Book(&quot;《编码》&quot;, 59.00));        //ArrayList默认的遍历顺序是元素的添加顺序        for (Book book : bookArrayList) &#123;            System.out.println(book.toString());        &#125;        System.out.println(&quot;-------------------------------------------&quot;);        //调用Collections.sort()方法，对集合中的元素按重写后的compare方法排序        Collections.sort(bookArrayList, new BookComparator());        //再次遍历，结果按照书本的价格从小到大排序        for (Book book : bookArrayList) &#123;            System.out.println(book.toString());        &#125;    &#125;&#125;\n总结Comparable与Comparator的区别\nComparable位于java.lang包下，Comparator位于java.util包下\nComparable接口的实现是在类的内部，Comparator接口的实现需要自定义一个排序类\n\n使用场景从上面二者的区别，我们容易知道：\n\n当排序的参数依据只在一个类中时，直接让该类实现Comparable接口并重写compareTo方法就可以了\n当排序的参数依据存在于多个类，更好的做法是自定义一个排序类，让其实现Comparator接口，并将需要用到的类传入过去，重写compare方法\n\n","categories":["Java"],"tags":["集合框架"]},{"title":"GC垃圾回收","url":"/2021/03/03/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","content":"本篇介绍Java中GC垃圾回收机制，包括垃圾的判断以及GC算法的演变过程\n\n垃圾回收的概念Java中的对象基本都存在堆区，堆区虽然很大，但存放对象的数量也是有限的，所以需要及时的清理那些不会再被使用到的对象，释放出内存空间以供其他对象使用\n判断是否为垃圾引用计数法从垃圾的定义出发，不会再被其他对象引用的对象被判定为垃圾\n那么最简单想到的一个方法就是统计该对象的引用个数，有新的变量引用该对象时，该对象的引用个数加1；反之该对象的一个引用失效时，引用个数减1。引用个数为0的对象被视为是垃圾，需要被回收\n上面内容还需要说明一个问题，引用失效怎么理解？最简单的，引用指向该对象后，设为了null，那么这个引用就相当于丢失了与这个对象的关联，自然就失效了。还有一个场景，一个垃圾对象的成员变量引用了其他对象，当这个垃圾对象被回收时，它的成员变量这个引用自然也就失效了\n但是这个方法有一个严重的缺陷，那就是当两个对象相互引用的时候，会导致循环引用而无法被回收，造成内存泄漏\n因此这个方法已经基本不再被使用了\n可达性分析在这个方法中，有个GC Roots的概念，GC会收集那些不是GC Roots且没有被GC Roots引用的对象。即被GC Roots直接或间接引用的对象不会被删除\n那么有哪些GC Roots呢？常见的有：栈、本地方法栈、方法区\n简单说明下原因：\n\n栈中存放的是当前正在运行的局部变量、函数、对象引用等，正在运行肯定是不能被删除的\n本地方法栈中存放的是native方法，调用更底层的C/C++代码，肯定不能被删除\n方法区存的是一些全局的变量，无法确定以后还会不会被用到，所以也不能删除\n\n更多关于GC Roots的内容可参见：\nhttps://help.eclipse.org/2020-12/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&amp;cp=37_2_3\nGC的三种思路标记—清理最简单的一种思路，利用可达性分析，将GC Roots直接或间接引用的对象标记上，被标记的对象不能被删除\n然后清理阶段，把没有被标记的对象清理掉\n缺点：会产生内存碎片\n标记—整理为了解决内存碎片问题，每清理掉一个垃圾，后面的对象就往前面凑紧，即整理\n缺点：代价太大，效率低\n复制和前两种思路不同，复制算法直接申请两块一样大的内存，在其中一块进行GC，清理掉垃圾后，将不被回收的对象紧凑的复制到另一块内存\n这种做法即避免了产生内存碎片，同时效率也不会太低\n但显而易见的缺点：需要两倍的内存开销\n实际的GC机制将堆区进行了划分，一部分叫Young区（新生代），另一部分叫old区（老年代）\nYoung区又分为三部分：Eden（译为伊甸园，即产生对象的区域）、From survivor、To survivor\n\nYoung区（新生代）new对象发生在E区，满了触发Young GC\nYoung GC采用的是“复制”算法\n\nIBM有专门研究表明新生代中的对象98%是朝生夕死的\n在堆中，尤其是在新生代，常规应用进行一次GC一般可以回收70%~95%的空间\n\n因为对象的朝生夕死特征，Young区的划分大小比例为：\nS0：S1：E ≈ 1：1：8\n为什么需要两个survivor区呢？因为S0区和S1区是交替工作的，这样的做法比直接将Young区一分为二的利用率要高一些\n模拟下Young GC的过程：\n\nE区存放new对象，满了触发Young GC\nYoung GC采用复制算法，标记E区中的存活对象，然后紧凑的复制到S0区\n将E区和S1区全部清理删除\n等下一次E区快满了的时候，将E区的存活对象和S0区标记并复制到S1区\n如此循环往复…\n\n思考个问题，E区和S0区的所有存活对象都可以复制到S1区吗？S1区能放下这么多对象吗？\n答案是，S1区是有可能放不下所有的存活对象的，这时候会直接放到old区\nold区（老年代）每次Young GC中存活下来的对象，年龄就加1，当年龄等于6时，就不再往survivor区复制，而是直接进到old区\n因为一个对象要是能在6次的GC中存活下来，那么认为它很有可能会一直存活下去\nold区还存放大对象，因为大对象如果在Young区往复复制的话，消耗是很大的\n当old区满了，也会触发GC，此时的old GC往往伴随着Young GC进行，故也叫Full GC\nFull GC会引起stop the world（STW）现象，即整个Java程序暂停，全力的进行垃圾回收（此时主要采取的是标记—清理或标记—整理的算法）\n垃圾收集器ParNew\nCMS\nG1\n","categories":["Java"],"tags":["Java","JVM"]},{"title":"Git的常用操作","url":"/2021/02/21/Git%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","content":"记录下Git的常用操作命令，顺便简单理解下工作区、暂存区、归档区和远端仓库的含义\n\n常用git命令git init\t#初始化为git仓库git add [文件名.后缀名]\t#将工作区的指定文件提交到缓冲区git add .\t#将工作区的所有文件提交到缓冲区git commit -m &quot;备注&quot;\t#将缓冲区的所有文件提交到归档区，并添加备注信息git remote add origin https://github.com/xxx/xxx.git\t#添加远端仓库，远端仓库名为origin，后面跟着实际指向的地址git push -u origin master\t#将本地归档区的所有文件提交到origin远端仓库的master分支git status\t#查看当前本地仓库的状态git log\t#查看所有提交过的版本信息，不包括已经被删除和回滚的操作git reflog\t#查看所有操作的记录，包括回滚的操作，常用于恢复本地的错误操作git reset [版本号]\t#代码回滚git reset --soft [版本号]\t#只将归档区回滚\tgit reset --mixed [版本号]\t#将归档区和缓冲区回滚\tgit reset --hard [版本号]\t#将归档区、缓冲区和工作区全部回滚\tgit revert [版本号]\t#撤销某次版本的修改，此版本之前和之后的操作都会保留，并将这次撤销作为一次新的提交git branch -v\t#查看分支情况git checkout -b [分支名]\t#checkout是切换分支，加一个-b可以同时建立新分支并切换到该分支下git merge [分支名]\t#将指定分支合并到当前分支git pull\t#拉取远端仓库的最新版本，并将远端同名分支合并到本地分支git fetch\t#获取到远端仓库的更新\tgit merge origin/master\t#将远端的主干分支合并过来\n工作流程\n问题思考缓冲区存在的意义？为什么不可以将工作区的内容直接提交到本地归档区呢？为什么要设置一个缓冲区（或者叫暂存区）？\n这要提到Git诞生之前的集中式版本控制工具SVN，它最重要的特性之一就是原子性提交，每一个提交都是由多个文件的修改组成，而且这个提交是原子性的，要么这些修改全部成功，要么全部失败。这一特性使得把项目整体还原到某个阶段或者时间点变得极为简便。\nGit为了继承这一优良特性，在commit之前，设置了一个暂存区，通过git add命令将所有需要提交修改的文件统一先提交到暂存区，然后再由git commit命令实现原子性操作，将缓冲区的所有文件一次性提交到本地归档区\n归档区存在的意义？同样的思考，归档区是不是也可以不要了呢？是否可以直接从本地提交到远端仓库呢？\n答案显然是否定的，因为代码的版本控制并不一定依赖于远端仓库，我们需要在本地就可以做一个版本的控制，这就是归档区存在的意义\n建议一个好的习惯：不要直接在master分支上解决冲突，应切换到其他分支，将master分支合并过来，在其他分支上修改解决冲突，完成后再切换到master分支，再把该分支合并到master分支上\nReferenceshttps://www.bilibili.com/video/BV1r741127CM\nhttps://www.zhihu.com/question/19946553\n","categories":["Git"],"tags":["Git"]},{"title":"Hexo中添加LaTex渲染","url":"/2018/12/23/Hexo%E4%B8%AD%E6%B8%B2%E6%9F%93LaTex/","content":"为了能在Markdown文本中优雅的插入数学公式，我们需要进行一些设置，让Hexo博客能正常地渲染LaTex\n\n更换渲染引擎默认渲染引擎是 hexo-renderer-marked，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签。hexo-renderer-kramed 引擎是在默认的渲染引擎的基础上修改了一些 bug ，两者比较接近，也比较轻量级。$ npm uninstall hexo-renderer-marked ––save $ npm install hexo-renderer-kramed ––save\n解决语义冲突进入node_modules\\kramed\\lib\\rules\\inline.js目录\n11行\n&#x2F;&#x2F;escape: &#x2F;^\\\\([\\\\&#96;*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])&#x2F;,  escape: &#x2F;^\\\\([&#96;*\\[\\]()#$+\\-.!_&gt;])&#x2F;,\n20行\n&#x2F;&#x2F;  em: &#x2F;^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)&#x2F;,  em: &#x2F;^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)&#x2F;,\n更改配置文件mathjax:  enable: true  per_page: true  #cdn: &#x2F;&#x2F;cdn.bootcss.com&#x2F;mathjax&#x2F;2.7.1&#x2F;latest.js?config&#x3D;TeX-AMS-MML_HTMLorMML  cdn: &#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;mathjax&#x2F;2.7.1&#x2F;MathJax.js?config&#x3D;TeX-AMS-MML_HTMLorMML\n打开mathjax开关在有需要使用LaTex的文章首添加：mathjax: true\n","categories":["Blog"],"tags":["Hexo","LaTex"]},{"title":"JDBC基础","url":"/2019/07/08/JDBC%E5%9F%BA%E7%A1%80/","content":"记录JDBC的一些基本概念和使用步骤\n\nJDBC简介JDBC（Java Database Connectivity）即：Java数据库连接JDBC只是一个抽象的编程接口，通过加载不同的数据库驱动，可以实现跨数据库平台Java中的java.sql和javax.sql包含JDBC编程的所有接口\nJDBC常用的接口和类\nDriverManager    驱动管理器获得数据库连接\nConnection    数据库连接接口\nStatement    语句接口，用来静态操作SQL语句\nPreparedStatement    预定义语句，用来动态操作SQL语句\nCallableStatement    可以调用存储过程的预定义语句\nResultSet    结果集，保存数据记录的结果集合\nResultSetMetaData    结果集元数据，如：列名称、列类型等\nDatabaseMetaData    数据元数据，如：数据库名称、版本等\n\nJDBC编程步骤\n加载数据库驱动（jar文件）\n获得数据库连接\n创建语句\n执行查询\n遍历结果集\n关闭数据库连接\n\n数据库连接数据库打开的连接数是有限的，所以连接使用完成需要关闭获得数据库连接的步骤：\n\nClass.forName加载驱动\nDriverManager获得连接\n\n\n常规方法\n\n//DBUtil.javapackage com.me.demo;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class DBUtil &#123;\tprivate static String driver;\tprivate static String url;\tprivate static String username;\tprivate static String password;\tstatic &#123;\t\tdriver = &quot;com.mysql.cj.jdbc.Driver&quot;;\t\turl = &quot;jdbc:mysql://localhost:3306/studentdb?serverTimezone=UTC&quot;;\t\tusername = &quot;root&quot;;\t\tpassword = &quot;lyx517hdjd&quot;;\t&#125;\t// 建立数据库连接\tpublic static Connection open() &#123;\t\ttry &#123;\t\t\tClass.forName(driver);\t\t\treturn DriverManager.getConnection(url, username, password);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\treturn null;\t&#125;\t// 关闭数据库连接\tpublic static void close(Connection conn) &#123;\t\tif (conn != null) &#123;\t\t\ttry &#123;\t\t\t\tconn.close();\t\t\t&#125; catch (SQLException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n//Test.javapackage com.me.demo;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class Test &#123;\tpublic static void main(String[] args) &#123;\t\tConnection conn = DBUtil.open();\t\tString sql = &quot;select * from student&quot;;\t\ttry &#123;\t\t\tStatement stmt = conn.createStatement();\t\t\tResultSet rs = stmt.executeQuery(sql);\t\t\twhile (rs.next()) &#123;\t\t\t\tint id = rs.getInt(1);\t\t\t\tString name = rs.getString(3);\t\t\t\tString sex = rs.getString(5);\t\t\t\tSystem.out.println(id + &quot;号:&quot; + name + &quot; 性别：&quot; + sex);\t\t\t&#125;\t\t&#125; catch (SQLException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tDBUtil.close(conn);\t\t&#125;\t&#125;&#125;\n\n配置文件动态获取\n\n\n为了在以后修改用户名和密码或者修改数据库驱动时，而不修改程序，可以将数据库配置信息写到配置文件里\n\n//DBUtil.javapackage com.me.demo;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.Reader;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.Properties;public class DBUtil &#123;\tprivate static String driver;\tprivate static String url;\tprivate static String username;\tprivate static String password;\tstatic &#123;\t\tProperties prop = new Properties();\t\tReader in;\t\ttry &#123;\t\t\tin = new FileReader(&quot;src\\\\config.properties&quot;);\t\t\tprop.load(in);\t\t&#125; catch (FileNotFoundException e) &#123;\t\t\te.printStackTrace();\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125;        //注意引号\t\tdriver = prop.getProperty(&quot;driver&quot;);\t\turl = prop.getProperty(&quot;url&quot;);\t\tusername = prop.getProperty(&quot;username&quot;);\t\tpassword = prop.getProperty(&quot;password&quot;);\t&#125;\t// 建立数据库连接\tpublic static Connection open() &#123;\t\ttry &#123;\t\t\tClass.forName(driver);\t\t\treturn DriverManager.getConnection(url, username, password);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\treturn null;\t&#125;\t// 关闭数据库连接\tpublic static void close(Connection conn) &#123;\t\tif (conn != null) &#123;\t\t\ttry &#123;\t\t\t\tconn.close();\t\t\t&#125; catch (SQLException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\nproperties实现动态获取注意config.properties中不能有空格、双引号和分号\n\ndriver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/studentdb?serverTimezone=UTCusername=rootpassword=lyx517hdjd\nStatement语句Statement语句是SQL语句的描述，使用它可以操作各种SQL语句，包括DDL（数据定义语句，如创建表）、DML（CRUD）和DCL等\nStatement对象常用方法：\n\nexecute(String sql)：用于向数据库发送任意sql语句\nexecuteQuery(String sql) ：只能向数据发送查询语句\nexecuteUpdate(String sql)：只能向数据库发送insert、 update或delete语句\naddBatch(String sql) ：把多条sql语句放到一个批处理中\nexecuteBatch()：向数据库发送一批sql语句执行\n\n下面是jdbc连接数据库实现crud的一个简单示例\n//Crud.javapackage com.me.demo;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class Crud &#123;\tpublic static void main(String[] args) &#123;\t\tquery();\t\t// insert();\t\t// update();\t\t// delete();\t&#125;\t// 查询操作\tstatic void query() &#123;\t\tConnection conn = DBUtil.open();\t\tString sql = &quot;select * from student&quot;;\t\ttry &#123;\t\t\tStatement stmt = conn.createStatement();\t\t\tResultSet rs = stmt.executeQuery(sql);\t\t\twhile (rs.next()) &#123;\t\t\t\tint id = rs.getInt(1);\t\t\t\tString name = rs.getString(&quot;student_name&quot;);\t\t\t\tString sex = rs.getString(5);\t\t\t\tSystem.out.println(id + &quot;号:&quot; + name + &quot; 性别：&quot; + sex);\t\t\t&#125;\t\t&#125; catch (SQLException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tDBUtil.close(conn);\t\t&#125;\t&#125;\t// 插入操作\tstatic void insert() &#123;\t\tConnection conn = DBUtil.open();\t\tString sql = &quot;INSERT INTO student ( student_number, student_name, student_password, student_sex )\\r\\n&quot;\t\t\t\t+ &quot;VALUES\\r\\n&quot; + &quot;\t( \\&quot;517\\&quot;, \\&quot;piccolo_devil\\&quot;, \\&quot;helloworld\\&quot;, 1 );&quot;;\t\ttry &#123;\t\t\tStatement stmt = conn.createStatement();\t\t\tstmt.executeUpdate(sql);\t\t&#125; catch (SQLException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tDBUtil.close(conn);\t\t&#125;\t&#125;\t// 更新操作\tstatic void update() &#123;\t\tConnection conn = DBUtil.open();\t\tString sql = &quot;update student set student_name=&#x27;更新测试&#x27; where student_name =&#x27;fff&#x27;;&quot;;\t\ttry &#123;\t\t\tStatement stmt = conn.createStatement();\t\t\tstmt.executeUpdate(sql);\t\t&#125; catch (SQLException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tDBUtil.close(conn);\t\t&#125;\t&#125;\t// 删除操作\tstatic void delete() &#123;\t\tConnection conn = DBUtil.open();\t\tString sql = &quot;delete from student where student_name =&#x27;更新测试&#x27;&quot;;\t\ttry &#123;\t\t\tStatement stmt = conn.createStatement();\t\t\tstmt.executeUpdate(sql);\t\t&#125; catch (SQLException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tDBUtil.close(conn);\t\t&#125;\t&#125;&#125;\n接下来引入面向对象的概念思想，创建一个JavaBean，封装student的所有属性，通过JavaBean来实现数据的传递\n// 查询操作\tstatic List&lt;student&gt; query() &#123;\t\tConnection conn = DBUtil.open();\t\tString sql = &quot;select * from student&quot;;\t\ttry &#123;\t\t\tStatement stmt = conn.createStatement();\t\t\tResultSet rs = stmt.executeQuery(sql);\t\t\tList&lt;student&gt; list = new ArrayList&lt;student&gt;();\t\t\twhile (rs.next()) &#123;\t\t\t\tint id = rs.getInt(1);\t\t\t\tString name = rs.getString(&quot;student_name&quot;);\t\t\t\tString sex = rs.getString(5);\t\t\t\t// System.out.println(id + &quot;号:&quot; + name + &quot; 性别：&quot; + sex);\t\t\t\tstudent sd = new student();\t\t\t\tsd.setStudent_id(id);\t\t\t\tsd.setStudent_name(name);\t\t\t\tsd.setStdent_sex(sex);\t\t\t\tlist.add(sd);\t\t\t&#125;\t\t\tSystem.out.println(list);\t\t\treturn list;\t\t&#125; catch (SQLException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tDBUtil.close(conn);\t\t&#125;\t\treturn null;\t&#125;\n此外为了输出的结果更美观，重写了toString方法\n@Override\tpublic String toString() &#123;\t\treturn student_id + &quot;,&quot; + student_name + &quot;,&quot; + stdent_sex;\t&#125;\nResultSet结果集\n用来获得SQL语句的查询结果\n结果集包含了SQL语句的查询结果数据\n调用语句的executeQuery方法返回结果集对象\nResultSet常用方法— next()：返回boolean类型数据，用来判断结果集中是否有数据— getXXX()：获得结果集中的数据项，可以根据列名称或者列索引\nResultSet还提供了对结果集进行滚动的方法：\n\n\nnext()：移动到下一行\nPrevious()：移动到前一行\nabsolute(int row)：移动到指定行\nbeforeFirst()：移动resultSet的最前面\nafterLast() ：移动到resultSet的最后面\n\nPreparedStatement语句\nPreparedStatement为预定义语句，继承Statement\nStatement只能静态操作SQL语句，而PreparedStatement能够实现SQL语句的动态操作，通过使用占位符”?”来预生成SQL语句\nPreparedStatement的优势\n\n\nPreperedStatement可以避免SQL注入的问题\nStatement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出\nPreparedStatement 可对SQL进行预编译，从而提高数据库的执行效率\nPreperedStatement对于sql中的参数，允许使用占位符的形式进行替换，简化sql语句的编写\n\n下面是一个用PreparedStatement语句实现的简单插入示例\npackage com.me.demo;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class Test2 &#123;\tpublic static void main(String[] args) &#123;\t\tinsert(&quot;666&quot;, &quot;666&quot;, &quot;666&quot;, &quot;1&quot;);\t&#125;\tstatic void insert(String number, String name, String password, String sex) &#123;\t\tString sql = &quot;INSERT INTO student ( student_number, student_name, student_password, student_sex ) values(?,?,?,?)&quot;;\t\tConnection conn = DBUtil.open();\t\tPreparedStatement pstmt;\t\ttry &#123;\t\t\tpstmt = conn.prepareStatement(sql);\t\t\tpstmt.setString(1, number);\t\t\tpstmt.setString(2, name);\t\t\tpstmt.setString(3, password);\t\t\tpstmt.setString(4, sex);\t\t\tpstmt.executeUpdate(); // 这句不能漏了\t\t&#125; catch (SQLException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tDBUtil.close(conn);\t\t&#125;\t&#125;&#125;\n同理，利用类对象实现的crud示例如下\npackage com.me.demo;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        // insert(&quot;666&quot;, &quot;666&quot;, &quot;666&quot;, &quot;1&quot;);\n\n        student sd = new student();\n        /*\n         * sd.setStudent_number(&quot;777&quot;); sd.setStudent_name(&quot;777&quot;);\n         * sd.setSudent_password(&quot;777&quot;); sd.setStdent_sex(&quot;1&quot;);\n         * \n         * insert(sd);\n         */\n        /*\n         * sd.setStudent_number(&quot;777&quot;); sd.setStudent_name(&quot;clearlove&quot;); update(sd);\n         */\n\n        // delete(&quot;clearlove&quot;);\n\n        sd = query(&quot;piccolo_devil&quot;);\n        if (sd != null)\n            System.out.println(sd.toString());\n    &#125;\n\n    static void insert(student sd) &#123;\n        String sql = &quot;INSERT INTO student ( student_number, student_name, student_password, student_sex ) values(?,?,?,?)&quot;;\n        Connection conn = DBUtil.open();\n        PreparedStatement pstmt;\n        try &#123;\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setString(1, sd.getStudent_number());\n            pstmt.setString(2, sd.getStudent_name());\n            pstmt.setString(3, sd.getStudent_password());\n            pstmt.setString(4, sd.getStdent_sex());\n            pstmt.executeUpdate();\n        &#125; catch (SQLException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            DBUtil.close(conn);\n        &#125;\n    &#125;\n\n    static void update(student sd) &#123;\n        String sql = &quot;update student set student_name = ? where student_number = ?&quot;;\n        Connection conn = DBUtil.open();\n        PreparedStatement pstmt;\n        try &#123;\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setString(1, sd.getStudent_name());\n            pstmt.setString(2, sd.getStudent_number());\n            pstmt.executeUpdate();\n        &#125; catch (SQLException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            DBUtil.close(conn);\n        &#125;\n    &#125;\n\n    static void delete(String name) &#123;\n        String sql = &quot;delete from student where student_name = ?&quot;;\n        Connection conn = DBUtil.open();\n        PreparedStatement pstmt;\n        try &#123;\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setString(1, name);\n            pstmt.executeUpdate();\n        &#125; catch (SQLException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            DBUtil.close(conn);\n        &#125;\n    &#125;\n\n    static student query(String name) &#123;\n        String sql = &quot;select student_id,student_number,student_name, student_password, student_sex from student where student_name=?&quot;;\n        Connection conn = DBUtil.open();\n        PreparedStatement pstmt;\n        try &#123;\n            pstmt = conn.prepareStatement(sql);\n            // 这里的下表是对应 ?\n            pstmt.setString(1, name);\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) &#123;\n                // 这里的下标是对应数据库表的顺序\n                int id = rs.getInt(1);\n                String number = rs.getString(2);\n                String password = rs.getString(4);\n                String sex = rs.getString(5);\n                student sd = new student();\n                sd.setStudent_id(id);\n                sd.setStudent_number(number);\n                sd.setStudent_name(name);\n                sd.setStudent_password(password);\n                sd.setStdent_sex(sex);\n                return sd;\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        &#125; finally &#123;\n            DBUtil.close(conn);\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n`\n\nCallableStatement语句\nCallableStatement继承自PreparedStatement，提供了调用存储过程的能力\nCallableStatement的用法：— 调用简单的存储过程— 调用有输入参数的存储过程— 调用有输入、输出参数的存储过程\n\nDAO设计模式DAO：Data Access Object，数据访问对象\n使用DAO设计模式，来封装数据库持久层的所有操作(CRUD)，使低级的数据逻辑和高级的业务逻辑分离，达到解耦合的目的\nDAO设计模式结构目录示例：Student                  ——&gt;       JavaBeanStudentDao           ——&gt;      接口类（定义CRUD方法）StudentDaoImpl   ——&gt;      接口类中方法的具体实现（CRUD方法的具体实现）main函数                ——&gt;      程序入口\n","categories":["Java"],"tags":["JDBC"]},{"title":"JVM内存结构","url":"/2021/03/03/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/","content":"简单了解下JVM的内存结构划分，各个部分的特点以及存储哪些东西\n\nJava虚拟机（JVM）拿到了自己能支配的内存之后，将内存进行了割分，分为以下五个区域：\n\nJVM栈存储局部变量表、操作数栈、动态链接、方法出口、对象引用等\nJVM栈中的元素被称为栈帧，方法开始执行时，对应的栈帧入栈，方法执行结束，栈帧出栈，对应内存空间被回收\n线程私有\n本地方法栈管理本地方法的调用，本地方法即native方法，即Java调用非Java代码的接口\n线程私有\n程序计数器用于存放下一条指令所在单元的地址，保证程序能正常执行下去\n在多线程环境下，由于采用时间片轮转方式，故需记录当前线程执行的位置，切换回来才知道上次运行到哪了\n线程私有\n堆最大的一块区域，用来存对象\nGC垃圾回收的主要区域\n线程共享\n方法区JDK8之前也叫永久代，使用的是JVM的内存空间；JDK8之后改名为元空间，使用的是本地内存，即能加载多少类，取决于本地内存大小\n主要存储一些静态的方法或变量、常量、类信息（构造方法/接口定义）、运行时常量池\n线程共享\n","categories":["Java"],"tags":["Java","JVM"]},{"title":"JavaScript基础语法","url":"/2021/01/24/JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","content":"记录JavaScript基础语法中比较不一样的点\n\n变量大小写敏感JavaScript 的变量名区分大小写，A和a是两个不同的变量\n默认值undefined如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个特殊的值，表示“无定义”\nvar a;a // undefined\n弱类型JavaScript 是一种动态类型语言，即变量不用指定具体的数据类型，也可以随时更改类型\nvar a = 1;a = &#x27;hello&#x27;;\n变量赋值可以省略var，但这种做法不推荐\nvar a = 1;// 基本等同a = 1;\n变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）\nconsole.log(a);var a = 1;\n上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。\nvar a;console.log(a);a = 1;\n最后的结果是显示undefined，表示变量a已声明，但还未赋值。\n中文标识符中文是合法的标识符，可以用作变量名，但这种做法不推荐\nvar 中文变量 = 1;\n注释单行注释：//\n多行注释：/*...*/\n此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;!--和--&gt;也被视为合法的单行注释\n注意：这里的“和”意思是，&lt;!--后的同一行内容会被注释掉，--&gt;后的同一行内容也会被注释掉（注意&lt;!--和--&gt;不能有空格）\nvar x;x = 1; &lt;!-- x = 2; //x=2被注释掉--&gt; x = 3; //--&gt;放在行首，视作单行注释，x=3也会被注释掉console.log(x); //因此此处打印出的x值为1\nvar x;x = 1; &lt;!-- x = 2; //x=2被注释掉--&gt;x = 3; //不同行，x=3就不会被注释掉console.log(x); //因此此处打印出的x值为3\n需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算\nfunction countdown(n) &#123;  while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0\n上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0\nJS中的==与=====：不是严格意义上的相等，比较的仅仅是两边变量的数值是否相等。当两边的值类型不同时，先进行类型转换再比较\n注意：==比较数值时，如果其中至少一个是NaN（只能用isNaN()判断），那么一定不等\n===：是严格意义上的恒等，首先比较两边的变量数据类型是否相等，然后再比较数值是否相等。不做类型转换，类型不同的一定不等\n注意：switch结构中采用的是严格相等运算符（===），即不发生类型转换\nvar x = 1;switch (x) &#123;  case true:    console.log(&#x27;x 发生类型转换&#x27;);    break;  default:    console.log(&#x27;x 没有发生类型转换&#x27;);&#125;// x 没有发生类型转换\n标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置\nlabel:  语句\n标签通常与break语句和continue语句配合使用，跳出特定的循环\ntop:  for (var i = 0; i &lt; 3; i++)&#123;    for (var j = 0; j &lt; 3; j++)&#123;      if (i === 1 &amp;&amp; j === 1) break top;      console.log(&#x27;i=&#x27; + i + &#x27;, j=&#x27; + j);    &#125;  &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0\ntop:  for (var i = 0; i &lt; 3; i++)&#123;    for (var j = 0; j &lt; 3; j++)&#123;      if (i === 1 &amp;&amp; j === 1) continue top;      console.log(&#x27;i=&#x27; + i + &#x27;, j=&#x27; + j);    &#125;  &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2\nReferenceshttps://wangdoc.com/javascript/basic/grammar.html\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"Java创建线程的几种方式","url":"/2021/02/18/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","content":"本篇介绍了Java中创建线程的几种方式\n\n继承Thread类public class CreateThreadDemo1 &#123;    public static class MyThread extends Thread &#123;        @Override        public void run() &#123;            System.out.println(&quot;Run MyThread!&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        Thread myThread = new MyThread();        myThread.start();    &#125;&#125;\nstart()方法会在内部自动调用实例的run()方法\n调用start()方法后，虚拟机先创建一个线程，然后等该线程第一次获得时间片时，调用run()方法\nThread类常用方法\ncurrentThread()：静态方法，返回对当前正在执行的线程对象的引用\nstart()：导致此线程开始执行，Java虚拟机调用此线程的run方法\nyield()：当前线程愿意让出对当前处理器的占用。注意，就算当前线程调用了yield()方法，也还有可能继续运行\nsleep()：静态方法，使当前正在执行的线程暂停指定的毫秒数\njoin()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的\n\n补充问题\n既然start()方法内部会自动调用run()方法，那为什么不直接调用run()方法？\nnew了一个Thread后，该线程处于初始化状态，必须要调用start()方法才会启动新线程，使其进入就绪状态，当该线程分配到时间片后即可运行，自动调用run()方法。但如果是直接调用run()方法，相当于只是调用了一个普通的Java方法，不会启动新线程\n\nsleep()方法和wait()方法的异同点？\n相同点：两者都可以暂停线程的执行\n不同点：\n\nsleep()方法没有释放锁；而wait()方法释放了锁（最主要区别）\nsleep()通常用于暂停线程的执行，线程睡眠指定时间之后会自动苏醒；而wait()方法通常用于线程间的通信，调用后不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法，或者超时等待状态下会自动苏醒\n\n\n\n实现Runnable接口public class CreateThreadDemo2 &#123;    public static class MyRunnable implements Runnable &#123;        @Override        public void run() &#123;            System.out.println(&quot;Run MyRunnable!&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        Thread myRunnable = new Thread(new MyRunnable());        myRunnable.start();    &#125;&#125;\nRunnable接口源码：\n@FunctionalInterfacepublic interface Runnable &#123;    public abstract void run();&#125;\n可见Runnable是一个函数式接口，可用Java 8的函数式编程来简化代码\npublic class CreateThreadDemo2 &#123;    public static void main(String[] args) &#123;        Thread myRunnable = new Thread(() -&gt; &#123;            System.out.println(&quot;Run MyRunnable!&quot;);        &#125;);        myRunnable.start();    &#125;&#125;\n比较Thread类和Runnable接口\n由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活\nRunnable接口出现更符合面向对象，将线程单独进行对象的封装\nRunnable接口出现，降低了线程对象和线程任务的耦合性\n如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量\n\n所以，通常优先使用“实现Runnable接口”这种方式来自定义线程类\n使用Callable、Future和FutureTask上述两种方式创建的进程，run()方法是没有返回值的\nJava还提供了Callable接口和Future接口。Callable接口提供的call()方法有返回值，可声明抛出异常，且支持泛型，可返回指定类型的结果。Future接口则用来接收Callable接口中call()方法的返回值\nCallable接口官方文档\nA task that returns a result and may throw an exception. Implementors define a single method with no arguments called call.\nThe Callable interface is similar to Runnable, in that both are designed for classes whose instances are potentially executed by another thread. A Runnable, however, does not return a result and cannot throw a checked exception.\n\n翻译：\n\n一个返回结果并可能引发异常的任务。 实现者定义一个没有参数的单一方法，称为call。\nCallable接口与Runnable相似，两者均适用于其实例可能由另一个线程执行的类。 但是，Runnable不会返回结果，也不能引发已检查的异常。\n\nFuture接口官方文档\nA Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task.\n\n翻译：\n\nFuture表示异步计算的结果。提供了一些方法来检查计算是否完成，等待其完成以及检索计算结果。只有在计算完成后才可以使用get方法检索结果，必要时将其阻塞，直到准备就绪为止。取消通过cancel方法执行。提供了其他方法来确定任务是正常完成还是被取消。一旦计算完成，就不能取消计算。如果您出于可取消性的目的而使用Future而不提供可用的结果，则可以声明Future &lt;？&gt;形式的类型，并作为基础任务的结果返回null。\n\nFutureTask类官方文档\nA cancellable asynchronous computation. This class provides a base implementation of Future, with methods to start and cancel a computation, query to see if the computation is complete, and retrieve the result of the computation. The result can only be retrieved when the computation has completed; the get methods will block if the computation has not yet completed. Once the computation has completed, the computation cannot be restarted or cancelled (unless the computation is invoked using runAndReset()).\nA FutureTask can be used to wrap a Callable or Runnable object. Because FutureTask implements Runnable, a FutureTask can be submitted to an Executor for execution.\nIn addition to serving as a standalone class, this class provides protected functionality that may be useful when creating customized task classes.\n\n翻译：\n\n可取消的异步计算。 此类提供Future的基本实现，其中包含启动和取消计算，查询以查看计算是否完成以及检索计算结果的方法。 只有在计算完成后才能检索结果； 如果计算尚未完成，则get方法将阻塞。 一旦计算完成，就不能重新启动或取消计算（除非使用runAndReset（）调用计算）。\nFutureTask可用于包装Callable或Runnable对象。 由于FutureTask实现了Runnable，因此FutureTask可以提交给执行程序以执行。\n除了用作独立类之外，此类还提供受保护的方法，这些方法在创建自定义任务类时可能很有用。\n\npublic class FutureTask&lt;V&gt; extends Object implements RunnableFuture&lt;V&gt;\npublic interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;\n可见，FutureTask类实现了RunnableFuture接口，而RunnableFuture接口同时继承了Runnable接口和Future接口\n由于Future只是一个接口，接口内部的方法需要自己实现，而JDK提供了FutureTask实现类供我们直接使用\n在高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下确保任务只执行一次\n使用Callable和Future创建线程的具体步骤如下：\n\n实现Callable接口，重写call()方法\n创建Callable实现类的实例，使用FutureTask类来包装Callable对象\n使用FutureTask对象作为Thread对象的target创建并启动线程\n调用FutureTask对象的get()方法获取子线程执行结束后的返回值\n\npackage create;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;//实现Callable接口class MyCallable implements Callable &#123;    //重写call()方法    @Override    public Integer call() throws Exception &#123;        int sum = 0;        for (int i = 1; i &lt; 101; i++) &#123;            sum += i;        &#125;        System.out.println(Thread.currentThread().getName() + &quot; is running: &quot; + sum);        return sum;    &#125;&#125;public class CreateThreadDemo3 &#123;    public static void main(String[] args) &#123;        //创建Callable实现类实例        MyCallable myCallable = new MyCallable();        //使用FutureTask类来包装Callable对象        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myCallable);        //使用FutureTask对象作为Thread对象的target创建并启动线程        new Thread(futureTask).start();        try &#123;            //调用FutureTask对象的get()方法获取子线程执行结束后的返回值            System.out.println(&quot;子线程的返回值: &quot; + futureTask.get());        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; catch (ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n线程池方式还可利用JDK提供的线程池来创建线程\n这部分内容之后再具体讨论…\nReferenceshttp://concurrent.redspider.group/article/01/2.html\nhttps://juejin.cn/post/6844903934180491272\n","categories":["Java"],"tags":["Java","多线程"]},{"title":"Java的值传递","url":"/2021/01/19/Java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92/","content":"C语言本身只支持值传递，它的衍生品C++既支持值传递，也支持引用传递，而Java只支持值传递\n\n几个错误的认知：\n认为值传递和引用传递的区分条件是传递的内容，如果传递的是值，就是值传递，传递的是个引用，就是引用传递\n认为传递的参数是基本数据类型，就是值传递，传递的参数是对象，就是引用传递\n\n形参与实参\n形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数\n实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”\n\n值传递与引用传递\n值传递（pass by value）：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数\n引用传递（pass by reference）：是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数\n\n案例分析public static void main(String[] args) &#123;    int num = 10;   //main中的num变量赋值并入栈    System.out.println(&quot;Before modify, num in main: &quot; + num);    modify(num);    //此操作将形参对应的实参copy一份副本，接下来进入modify方法    System.out.println(&quot;After modify, num in main: &quot; + num);&#125;public static void modify(int num) &#123;    num = 20;   //将副本中num值改为20    System.out.println(&quot;num in modify: &quot; + num);&#125;\n输出：\nBefore modify, num in main: 10num in modify: 20After modify, num in main: 10\n内存分析：\n\npublic static void main(String[] args) &#123;    /*     * Person person操作，在栈中声明了一个引用类型变量     * new Person(&quot;Tom&quot;,18)操作，在堆中申请了一块内存空间，存放Person对象，并调用类的带参构造方法初始化了对象     * =赋值操作，使左边栈中的person变量指向右边堆中的对象，person中的值存的是对象的地址,eg: base.Person@1b6d3586     */    Person person = new Person(&quot;Tom&quot;, 18);    //System.out.println(person);    System.out.println(&quot;name: &quot; + person.getName() + &quot;; age: &quot; + person.getAge());    /*     * 在栈中新建了一个person变量的copy副本     * 副本也是引用类型，也指向同一个Person对象     */    modify(person);    System.out.println(&quot;name: &quot; + person.getName() + &quot;; age: &quot; + person.getAge());&#125;public static void modify(Person person) &#123;    /*     * 由于副本指向的对象与实参变量指向的是同一个对象     * 因而通过副本对指向对象的修改操作，将直接影响同一个对象     */    person.setName(&quot;Bob&quot;);    person.setAge(20);&#125;\n输出：\nname: Tom; age: 18name: Bob; age: 20\n内存分析：\n\n总结值传递与引用传递的根本区别就是是否会创建副本（Copy）。也正是因为值传递会创建副本，所以在函数中的修改无法改变原始对象；而引用传递不创建副本，直接指向同一个对象，所以在函数中的修改会改变原始对象。从上面两个例子中可以看出，Java对引用类型的数据传递，也是通过创建副本的形式进行的，只不过对于对象参数，值传递的内容是对象的引用。\nReferences为什么Java中只有值传递\n","categories":["Java"],"tags":["Java"]},{"title":"Java线程间的通信","url":"/2021/02/20/Java%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/","content":"本篇介绍了实现Java线程间通信的几种方式\n\n锁与同步一个锁在同一时间只能被一个线程所持有\n在多线程的环境下，线程的调度是由操作系统决定的，如果多个线程同时读写共享变量，就容易出现数据不一致的问题，这时就需要解决同步问题\n一个最简单的办法，就是使用同步关键字synchronized加上锁，来实现线程同步\n示例：实现两个线程的顺序执行，即先执行完线程A再执行线程B\npublic class SyncDemo1 &#123;    //声明一个对象锁    private static Object lock = new Object();    static class ThreadA implements Runnable &#123;        @Override        public void run() &#123;            //synchronized + 锁            synchronized (lock) &#123;                for (int i = 0; i &lt; 100; i++) &#123;                    System.out.println(&quot;ThreadA: &quot; + i);                &#125;            &#125;        &#125;    &#125;    static class ThreadB implements Runnable &#123;        @Override        public void run() &#123;            synchronized (lock) &#123;                for (int i = 0; i &lt; 100; i++) &#123;                    System.out.println(&quot;ThreadB: &quot; + i);                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(new ThreadA()).start();        Thread.sleep(10);        new Thread(new ThreadB()).start();    &#125;&#125;\n等待/通知机制上述synchronized+锁的方式，线程会不断地尝试获取锁，这会一直耗费资源\n而等待/通知机制基于Object类的wait()、notify()和notifyAll()方法，它使用wait()方法让线程进入等待状态，从而释放自己持有的锁，notify()和notifyAll()方法则能够唤醒特定或其他所有的正在等待的线程（注意：唤醒其他线程不代表就已经释放了自己所持有的锁，只有线程执行结束会自动释放锁，还有就是主动调用wait()方法来释放锁）\n示例：实现两个线程的交替执行\npublic class SyncDemo2 &#123;    private static Object lock = new Object();    static class ThreadA implements Runnable &#123;        @Override        public void run() &#123;            synchronized (lock) &#123;                for (int i = 0; i &lt; 5; i++) &#123;                    try &#123;                        System.out.println(&quot;ThreadA: &quot; + i);                        //A线程每执行一次，就唤醒其他线程，然后释放掉自己持有的锁                        lock.notify();                        lock.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                lock.notify();            &#125;        &#125;    &#125;    static class ThreadB implements Runnable &#123;        @Override        public void run() &#123;            synchronized (lock) &#123;                for (int i = 0; i &lt; 5; i++) &#123;                    try &#123;                        System.out.println(&quot;ThreadB: &quot; + i);                        //B线程也是如此，从而实现A、B线程交替执行                        lock.notify();                        lock.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                lock.notify();            &#125;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(new ThreadA()).start();        Thread.sleep(1000);        new Thread(new ThreadB()).start();    &#125;&#125;\n信号量JDK提供了一个类似于“信号量”功能的类Semaphore\n此处只简单介绍基于volatile关键字实现的模拟信号量通信\n示例：实现两个线程交替执行，线程A输出0，然后线程B输出1，再然后线程A输出2…\npublic class Signal &#123;    private static volatile int signal = 0;    static class ThreadA implements Runnable &#123;        @Override        public void run() &#123;            while (signal &lt; 5) &#123;                if (signal % 2 == 0) &#123;                    System.out.println(&quot;threadA: &quot; + signal);                    signal++;                &#125;            &#125;        &#125;    &#125;    static class ThreadB implements Runnable &#123;        @Override        public void run() &#123;            while (signal &lt; 5) &#123;                if (signal % 2 == 1) &#123;                    System.out.println(&quot;threadB: &quot; + signal);                    signal = signal + 1;                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(new ThreadA()).start();        Thread.sleep(1000);        new Thread(new ThreadB()).start();    &#125;&#125;\n注意：volatile变量需要进行原子操作，但是上述示例中signal++并不是原子操作。在实际开发中，会根据需要使用synchronized加锁，或者使用AtomicXXX原子类\n管道前面几种都是共享内存方式的通信，而管道通信则像是消息传递方式的通信，通过管道，将一个线程中的消息发送给另一个\nJDK提供了PipedWriter、 PipedReader、 PipedOutputStream、 PipedInputStream。其中，前两个基于字符，后两个基于字节流\npublic class Pipe &#123;    static class ReaderThread implements Runnable &#123;        private PipedReader reader;        public ReaderThread(PipedReader reader) &#123;            this.reader = reader;        &#125;        @Override        public void run() &#123;            System.out.println(&quot;this is reader&quot;);            int receive = 0;            try &#123;                while ((receive = reader.read()) != -1) &#123;                    System.out.print((char)receive);                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    static class WriterThread implements Runnable &#123;        private PipedWriter writer;        public WriterThread(PipedWriter writer) &#123;            this.writer = writer;        &#125;        @Override        public void run() &#123;            System.out.println(&quot;this is writer&quot;);            int receive = 0;            try &#123;                writer.write(&quot;test&quot;);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; finally &#123;                try &#123;                    writer.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) throws IOException, InterruptedException &#123;        PipedWriter writer = new PipedWriter();        PipedReader reader = new PipedReader();        writer.connect(reader); // 这里注意一定要连接，才能通信        new Thread(new ReaderThread(reader)).start();        Thread.sleep(1000);        new Thread(new WriterThread(writer)).start();    &#125;&#125;\nReferenceshttp://concurrent.redspider.group/article/01/5.html\n","categories":["Java"],"tags":["Java","多线程"]},{"title":"Linux文件管理常用命令","url":"/2021/04/28/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"学习记录一下Linux中文件与目录管理相关的命令操作\n\ncd\n说明：进入某个目录\n用法：\n\ncd ./    进入当前目录\ncd ../    进入当前目录的上一级目录\n\nalias\n说明：设置指令别名\n用法：alias [别名] = [指令名称]\n补充：\n为什么使用命令时直接输入命令名，不用添加其绝对路径？\n先打印出环境变量PATH的值查看一下\n[root@centos7 ~]# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n再查看下ls命令的绝对路径\n[root@centos7 ~]# which lsalias ls=&#x27;ls --color=auto&#x27;\t/usr/bin/ls\n可以看到，环境变量PATH中已经记录了/usr/bin/这个路径，所以当我们使用ls命令时就能直接输入ls，而不用输入其完整路径了\nln\n说明：用于为文件创建连接\n用法：ln –s [源文件] [目标文件]\n-s 创建软连接（也叫符号连接）\numask\n说明：指定在建立文件时预设的权限掩码\nQ: 在linux系统中，默认一个目录的权限为 755（drwxr-xr-x），而一个文件的默认权限为644（-rw-r—r—）。这个权限值是怎么规定的呢？\nA: umask指定在建立文件时预设的权限掩码\n\n若用户建立为普通文件，则预设“没有可执行权限”，只有rw两个权限。最大为666（-rw-rw-rw-）\n若用户建立为目录，则预设所有权限均开放，即777（drwxrwxrwx）\n\numask值的含义：上述两条规则中的默认值需要减掉的权限值\numask默认为0022，还可自定义umask值\numask 可以在/etc/bashrc里面更改，预设情况下，root的umask为022，而一般使用者则为002，因为可写的权限非常重要，因此预设会去掉写权限\nmkdir\n说明：创建一个目录\n若上级目录不存在或重复创建已存在的目录，则会提示报错无法创建，解决方案：可用 -p 参数递归地创建\ntouch\n说明：如果该文件存在，则将其时间标签更新为系统当前的时间，否则创建新的空文件\ngroupadd\n说明：增加一个用户组\nrmdir\n说明：删除一个目录\n类似的，-p 参数会递归删除命令后带的路径上的所有目录\n但是rmdir无法删除一个不为空的文件夹，且只能删目录不能删文件\nrm\n说明：删除目录或文件\n当要用rm删除目录时需加上 -r 参数\n-f 强制删除（不加 -f 的话，删除一个不存在的文件时会报错）\ncp\n说明：拷贝文件或目录\n用法：cp [选项] [ 源文件 ] [目标文件]\n如果需要拷贝目录需加上 -r 参数\ncp命令带上 -d 参数时，拷贝的是连接文件（快捷方式），不带 -d 参数拷贝软连接时会把软连接实际连接到的目标文件拷贝过去\n-i 询问是否覆盖已存在的文件\n-u 该选项仅当目标文件存在时才会生效，如果源文件比目标文件新才会拷贝，否则不做任何动作\n案例：\n[root@centos7 test]# ls[root@centos7 test]# touch test[root@centos7 test]# ln -s test test1[root@centos7 test]# ls -l test test1-rw-r--r--. 1 root root 0 Apr 28 00:05 testlrwxrwxrwx. 1 root root 4 Apr 28 00:05 test1 -&gt; test[root@centos7 test]# cp test1 test2[root@centos7 test]# ll test test1 test2-rw-r--r--. 1 root root 0 Apr 28 00:05 testlrwxrwxrwx. 1 root root 4 Apr 28 00:05 test1 -&gt; test-rw-r--r--. 1 root root 0 Apr 28 00:06 test2[root@centos7 test]# cp -d test1 test3[root@centos7 test]# ll test test1 test2 test3-rw-r--r--. 1 root root 0 Apr 28 00:05 testlrwxrwxrwx. 1 root root 4 Apr 28 00:05 test1 -&gt; test-rw-r--r--. 1 root root 0 Apr 28 00:06 test2lrwxrwxrwx. 1 root root 4 Apr 28 00:06 test3 -&gt; test\nmv\n说明：移动文件\n用法：mv [ 选项 ] [源文件] [目标文件]\n可用于Linux下重命名\n案例：\n[root@centos7 tmp]# cd test_mv[root@centos7 test_mv]# ls[root@centos7 test_mv]# mkdir aa bb[root@centos7 test_mv]# lsaa  bb[root@centos7 test_mv]# mv aa cc[root@centos7 test_mv]# lsbb  cc[root@centos7 test_mv]# ls cc[root@centos7 test_mv]# mv cc bb[root@centos7 test_mv]# lsbb[root@centos7 test_mv]# ls bbcc[root@centos7 test_mv]# touch dd[root@centos7 test_mv]# lsbb  dd[root@centos7 test_mv]# mv dd ee[root@centos7 test_mv]# lsbb  ee[root@centos7 test_mv]# mv ee bb[root@centos7 test_mv]# ls bbcc  ee\nchgrp\n说明：更改所属组\n用法：chgrp [组名] [文件名]\n案例：\n[root@centos7 tmp]# groupadd testgroup[root@centos7 tmp]# touch test1[root@centos7 tmp]# lltotal 4-rwx------. 1 root root 836 Apr 25 18:07 ks-script-_8iMRgdrwxr-xr-x. 2 root root  57 Apr 28 00:06 test-rw-r--r--. 1 root root   0 Apr 28 18:46 test1drwxr-xr-x. 3 root root  16 Apr 28 01:09 test_mv-rw-------. 1 root root   0 Apr 25 18:01 yum.log[root@centos7 tmp]# chgrp testgroup test1[root@centos7 tmp]# lltotal 4-rwx------. 1 root root      836 Apr 25 18:07 ks-script-_8iMRgdrwxr-xr-x. 2 root root       57 Apr 28 00:06 test-rw-r--r--. 1 root testgroup   0 Apr 28 18:46 test1drwxr-xr-x. 3 root root       16 Apr 28 01:09 test_mv-rw-------. 1 root root        0 Apr 25 18:01 yum.log\nchown\n说明：更改所属主\n用法：\nchown [ -R ] 账户名 文件名\nchown [ -R ] 账户名:组名 文件名\n-R 参数只作用于目录，作用是级联更改，即不仅更改当前目录，连目录里的目录和文件也全部更改\n案例：\n[root@centos7 tmp]# useradd user1[root@centos7 tmp]# ls -ld test_chowndrwxr-xr-x. 2 root root 6 Apr 28 19:01 test_chown[root@centos7 tmp]# touch test_chown/test1[root@centos7 tmp]# ls -l test_chowntotal 0-rw-r--r--. 1 root root 0 Apr 28 19:02 test1[root@centos7 tmp]# chown user1 test_chown[root@centos7 tmp]# ls -ld test_chowndrwxr-xr-x. 2 user1 root 19 Apr 28 19:02 test_chown[root@centos7 tmp]# ls -l test_chowntotal 0-rw-r--r--. 1 root root 0 Apr 28 19:02 test1[root@centos7 tmp]# chown -R user1:testgroup test_chown[root@centos7 tmp]# ls -ld test_chowndrwxr-xr-x. 2 user1 testgroup 19 Apr 28 19:02 test_chown[root@centos7 tmp]# ls -l test_chowntotal 0-rw-r--r--. 1 user1 testgroup 0 Apr 28 19:02 test1\nchmod\n说明：更改权限\n用法：chmod [-R] xxx 文件名 （这里的xxx表示数字）\n补充：\n\n-R：级联更改\n\nr：4；w：2；x：1；-：0\n\n在linux系统中，默认一个目录的权限为 755（drwxr-xr-x），而一个文件的默认权限为644（-rw-r—r—）\n即默认目录的权限为：所属主拥有全部权限，所属组和其他用户只可打开该目录（目录的执行权限等同于可读权限）\n默认文件的权限为：所属主可读可写，所属组和其他用户只可读\n\n\n特别的：chmod还支持使用rwx的方式来设置权限\n\nu：user（所属主）\ng：group（所属组）\no：others（其他用户）\na：all（全体）\n+：加入权限\n-：删除权限\n=：赋值权限\n\n案例：\n[root@centos7 test_chmod]# lltotal 0-rw-r--r--. 1 root root 0 Apr 28 21:44 test[root@centos7 test_chmod]# chmod u=rwx,g=rw,o=rw test[root@centos7 test_chmod]# lltotal 0-rwxrw-rw-. 1 root root 0 Apr 28 21:44 test[root@centos7 test_chmod]# chmod u-x,g+x,o-w test[root@centos7 test_chmod]# lltotal 0-rw-rwxr--. 1 root root 0 Apr 28 21:44 test[root@centos7 test_chmod]# chmod a=rwx test[root@centos7 test_chmod]# lltotal 0-rwxrwxrwx. 1 root root 0 Apr 28 21:44 test\nchattr\n说明：修改文件的特殊属性（暂不了解~）\nls\n说明：查看某个目录或文件\n-a 会列出所有的文件和目录（包括隐藏的）\n-l 会详细列出文件的属性信息，包括大小、创建日期、所属主所属组等等\nls -l 等同于 ll\npwd\n说明：显示当前所在目录\ncat\n说明：查看文件内容并显示在屏幕上\n-n 参数显示行号\n-A 显示所有内容，包括特殊字符\ntac\n说明：反向cat，反向打印\nmore\n说明：查看文件内容\n区别于cat的是，cat出的内容一个屏幕放不下的时候无法看到前面的，more可以按空格继续看下一屏，按 q 提前退出\nless\n说明：查看文件内容\n类似于more，除了按空格外，还能上下翻。按 j 下移一行，按 k 上移一行。特别的，more和less查看文件时，还可以搜索特定字符，按 / 输入word是当前行向下搜，按 ? 输入word是当前行向上搜，搜出多个按 n 显示下一个\nhead\n说明：查看文件内容\n默认显示文件的前十行。-n 参数可设置显示行数，如：head -n 5 [文件名]，将显示文件的前5行\ntail\n说明：查看文件内容\n类似于head，tail显示最后十行，同样可用 -n 参数指定行数\n如果文件是不断增加的，可用 -f 参数动态显示\nlsattr\n说明：列出文件/目录的特殊属性（暂不了解~）\nwhich\n说明：查找一个命令的绝对路径\nwhich只能用来查找PATH环境变量中出现的路径下的可执行文件\n当查找的文件在PATH变量中并没有时，就会报错\nwhereis\n说明：查找二进制程序（-b）、源代码文件（-s）和man手册页（-m）等相关文件路径\n和find相比，whereis查找的速度非常快\n因为Linux系统会将系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate命令时，会从数据库中查找数据，而不是像find那样通过遍历硬盘来查找，所以效率更高\n但是该数据库文件并不是实时更新的，默认情况下一星期更新一次，因此我们在用whereis和locate查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件却无法查找到，原因就是数据库文件没有被更新\nlocate\n说明：类似于whereis，也是通过查找预先生成的文件列表库来告诉用户要查找的文件在哪里\n具体用法不深究，用的不多~\nfind\n说明：Linux下最常用的搜索工具，在指定目录下查找文件\n用法：find [路径] [参数]\n案例：\n\n列出当前目录及子目录下所有文件和文件夹\nfind .\n\n在/home目录下查找以.txt结尾的文件名（若要忽略大小写则使用-iname）\nfind /home -name &quot;*.txt&quot;\n\n当前目录及子目录下查找所有以.txt和.pdf结尾的文件\nfind . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;# 或find . \\( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \\)\n\n匹配文件路径或者文件\nfind /usr/ -path &quot;*local*&quot;\n\n基于正则表达式匹配文件路径\nfind . -regex &quot;.*\\(\\.txt\\|\\.pdf\\)$&quot;\n\n找出/home目录下不是以.txt结尾的文件（否定参数）\nfind /home ! -name &quot;*.txt&quot;\n\n根据文件类型进行搜索\nfind . -type 类型参数\n类型参数列表：\n\nf：普通文件\nl：符号连接（软连接）\nd：目录\nc：字符设备\nb：块设备\ns：套接字\np：Fifo\n\n\n根据文件时间戳进行搜索\nfind . -type f 时间戳\nLinux系统每个文件都有三种时间戳：\n\n访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间\n修改时间（-mtime/天，-mmin/分钟）：文件最近一次修改时间\n变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间\n\n例如：搜索最近7天内被访问过的所有文件\nfind . -type f -atime -7\n\n\n关于find还有很多种用法，暂且列举这么些~\n","categories":["Linux"],"tags":["Linux"]},{"title":"List实现类","url":"/2021/02/05/List%E5%AE%9E%E7%8E%B0%E7%B1%BB/","content":"本篇详细介绍了List实现类中的ArrayList、Vector和LinkedList\n\nArrayListArrayList是容量可变的动态数组\n特点底层实现：数组Object[]\n查找快，增删慢，线程不安全\n常用方法ArrayList实现了List接口，常用方法示例参照List接口的demo\n\nadd(E e)    添加元素\nremove(int index)    删除指定索引处的元素\nclear()    清空列表\nclone()     返回ArrayList实例的浅拷贝\nsize()    返回元素个数\nget(int index)    通过索引获取元素\nindexOf(Object o)    返回指定元素索引值\ncontains(Object o)    判断是否包含\nisEmpty()    判断是否为空\nsubList(int fromIndex, int toIndex)    获取子列表\nset(int index, E element)    用指定的元素替换指定位置的元素\n\n源码分析\n快速随机访问：通过元素的序号快速获取元素对象(对应于get(int index)方法)\n\n//ArrayList继承了AbstractList，并实现了List接口，当然还实现了一些其他的接口//RandomAccess：支持快速随机访问//Cloneable：覆盖了clone()，能被克隆//java.io.Serializable：支持序列化public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;    private static final long serialVersionUID = 8683452581122892189L;    //默认的容量大小    private static final int DEFAULT_CAPACITY = 10;    //用于空实例的空数组    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;    //用于默认大小的空数组实例，将此与EMPTY_ELEMENTDATA区别开来，以便于知道添加第一个元素时需要扩容多少    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;\t//存储ArrayList元素的数组，初始大小是0，当有数据插入时，扩容到DEFAULT_CAPACITY = 10    transient Object[] elementData; // non-private to simplify nested class access    //elementData数组中含有的元素个数    private int size;    \t/* 三种初始化构造方法 */        //1. 默认无参构造，初始为空数组，当添加第一个元素后，容量变为10    public ArrayList() &#123;        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    &#125;        //2. 带初始容量参数的构造函数    public ArrayList(int initialCapacity) &#123;        if (initialCapacity &gt; 0) &#123;//初始容量大于0，创建initialCapacity大小的数组            this.elementData = new Object[initialCapacity];        &#125; else if (initialCapacity == 0) &#123;//初始容量等于0，创建空数组            this.elementData = EMPTY_ELEMENTDATA;        &#125; else &#123;//初始容量小于0则抛出异常            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                               initialCapacity);        &#125;    &#125;        //3. 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回    public ArrayList(Collection&lt;? extends E&gt; c) &#123;        elementData = c.toArray();        if ((size = elementData.length) != 0) &#123;            // c.toArray might (incorrectly) not return Object[] (see 6260652)            if (elementData.getClass() != Object[].class)                elementData = Arrays.copyOf(elementData, size, Object[].class);        &#125; else &#123;            // replace with empty array.            this.elementData = EMPTY_ELEMENTDATA;        &#125;    &#125;    //更多源码暂未接触...&#125;\n扩容机制public boolean add(E e) &#123;    //判断添加数据后是否需要扩容，并完成扩容操作    ensureCapacityInternal(size + 1);  // Increments modCount!!    //扩容处理完成后，把新元素追加到数组尾部    elementData[size++] = e;    return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;//计算所需要的最小容量private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;    //当elementData还是一个空数组时，即还未添加任何数据，会扩容到DEFAULT_CAPACITY = 10和minCapacity之间的最大值    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        return Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    return minCapacity;&#125;//判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) &#123;    //修改次数    modCount++;    //如果所需要的最小容量比elementData数组长度大，则需要进行扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);&#125;//扩容机制【重点】private void grow(int minCapacity) &#123;    //当前存放元素的数组大小    int oldCapacity = elementData.length;    //【关键】新容量为旧容量的1.5倍    //右移一位相当于/2，位运算的速度远快于除法运算    //注意：对偶数来说是1.5，对奇数来说是近似于1.5    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    //若扩容1.5倍后还不满足，则新容量直接设为所需要的最小容量    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    //检查新容量是否超出了ArrayList所定义的最大容量，    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE        newCapacity = hugeCapacity(minCapacity);    //将原数组元素拷贝到扩容后的新数组中    elementData = Arrays.copyOf(elementData, newCapacity);&#125;\n为什么扩容因子是1.5？\n扩容的容量太小会导致需要频繁扩容，从而需要频繁的申请内存空间和数组拷贝，从而降低性能\n\n扩容的容量太大会导致内存空间资源浪费\n\n\n扩容因子为1.5时，就能充分利用空间资源，且1.5的设置可以充分利用移位操作，减少了浮点数的使用，减少了运算次数和运算时间，从而增加了效率\nVectorVector也是动态数组，但是在现在的开发中已经不常用了\n特点底层实现：数组Object[]\n查找快、增删慢，线程安全\n由于是线程安全的，区别于ArrayList，故运行效率比ArrayList要稍慢一点\n这也是为什么Vector不被推荐使用的原因：作为普通的集合类，每个方法都实现了同步，极大地影响了使用效率\n常用方法由于Vector也实现了List接口，故一些常用方法的使用类似，不再赘述\nVector从JDK1.0开始就有了，因此它还包含了许多传统的方法\n//Vector还可以使用枚举器进行遍历System.out.println(&quot;使用枚举器遍历Vector中元素：&quot;);Enumeration enumeration = vector.elements();while (enumeration.hasMoreElements()) &#123;    System.out.println(enumeration.nextElement());&#125;//查找System.out.println(vector.firstElement());  //返回容器的第一个元素System.out.println(vector.lastElement());   //返回容器的最后一个元素System.out.println(vector.elementAt(1));    //返回指定索引上的元素\n枚举器与迭代器之间的区别枚举是初始Java版本JDK1.0的一部分，尽管迭代器与集合框架一起包含在JDK 1.2中，该框架也仅在JDK 1.2中添加。迭代器被设计为仅专注于集合框架，在Java集合框架中，迭代器代替了枚举\n迭代器与枚举有两种不同：\n\n迭代器允许调用者在迭代过程中使用定义明确的语义从基础集合中删除元素\n方法名称已得到改进\n\n\n\n\n\n枚举器\n迭代器\n\n\n\n\nhasMoreElement()\nhasNext()\n\n\nnextElement()\nnext()\n\n\n不适用\nremove()\n\n\n\n\nJava API 规范建议，对于较新的程序，应首选迭代器而不是枚举\n源码分析//Vector的四种构造方法//1. 无参构造，创建一个默认的向量，默认大小为 10public Vector() &#123;    this(10);&#125;//2. 创建指定大小的向量public Vector(int initialCapacity) &#123;    this(initialCapacity, 0);&#125;//3. 创建一个包含集合 c 元素的向量public Vector(Collection&lt;? extends E&gt; c) &#123;    elementData = c.toArray();    elementCount = elementData.length;    // c.toArray might (incorrectly) not return Object[] (see 6260652)    if (elementData.getClass() != Object[].class)        elementData = Arrays.copyOf(elementData, elementCount, Object[].class);&#125;//4. 创建指定大小的向量，并且指定增量。增量表示向量每次增加的元素数目public Vector(int initialCapacity, int capacityIncrement) &#123;    super();    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    this.elementData = new Object[initialCapacity];    this.capacityIncrement = capacityIncrement;&#125;\n扩容机制private void grow(int minCapacity) &#123;    // overflow-conscious code    int oldCapacity = elementData.length;    //Vector的扩容与ArrayList不同    //若容量增量大于0（即指定了容量增量），则新容量 = 旧容量 + 容量增量；否则新容量 = 2 * 旧容量    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                     capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);&#125;\nLinkedList特点底层实现：双向链表\n查找慢、增删快，线程不安全\n常用方法与ArrayList类似，还有一些特有的符合LinkedList特性的方法\nlinkedList.addFirst(&quot;Head&quot;);    //列表头部插入元素linkedList.addLast(&quot;Tail&quot;);     //列表尾部插入元素\n注意的是，LinkedList还实现了Deque接口，因此还具有peek、poll、pop、push等方法\nSystem.out.println(linkedList.peek());  //检索但不删除此列表的头System.out.println(linkedList); //[Head,...,Tail]System.out.println(linkedList.poll());  //检索并删除此列表的头System.out.println(linkedList); //[,...,Tail]linkedList.push(&quot;PushElem&quot;);    //将元素推送到由此列表表示的堆栈上System.out.println(linkedList); //[PushElem,...]System.out.println(linkedList.pop());   //从此列表表示的堆栈中弹出一个元素\n源码分析//继承了 AbstractSequentialList 类//实现了 List 接口，可进行列表的相关操作//实现了 Deque 接口，可作为队列使用//实现了 Cloneable 接口，可实现克隆//实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;    //链表中的元素个数    transient int size = 0;\t    //头节点    transient Node&lt;E&gt; first;\t    //尾节点    transient Node&lt;E&gt; last;        //...&#125;//节点类的结构private static class Node&lt;E&gt; &#123;    E item;\t//节点数据    Node&lt;E&gt; next;\t//后一个节点的链接    Node&lt;E&gt; prev;\t//前一个节点的链接    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        this.item = element;        this.next = next;        this.prev = prev;    &#125;&#125;\nadd()添加数据的实现逻辑public boolean add(E e) &#123;    linkLast(e);    return true;&#125;void linkLast(E e) &#123;    final Node&lt;E&gt; l = last;\t//l指向添加前的链表的最后一个节点    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);\t//将新添加节点的头指针指向原链表最后一个节点的尾指针    last = newNode;\t//更新last指向新添加的节点    if (l == null)        first = newNode;\t//用于标明第一个节点    else        l.next = newNode;\t//将原链表的最后一个元素的尾指针指向新添加节点（即到此完成“双向”）    size++;    modCount++;&#125;\nget()查找数据的实现逻辑public E get(int index) &#123;    //检查下标是否越界    checkElementIndex(index);    //返回执行下标处的元素值    return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123;    // assert isElementIndex(index);\t//可见，LinkedList查找指定下标处的元素值的方法只能是依次遍历，故查找效率慢    if (index &lt; (size &gt;&gt; 1)) &#123;\t//前半部分，从前往后找        Node&lt;E&gt; x = first;        for (int i = 0; i &lt; index; i++)            x = x.next;        return x;    &#125; else &#123;\t//后半部分，从后往前找        Node&lt;E&gt; x = last;        for (int i = size - 1; i &gt; index; i--)            x = x.prev;        return x;    &#125;&#125;\n总结ArrayList与Vector的区别：ArrayList线程不安全，Vector线程安全\nArrayList与LinkedList的区别：\n\n底层实现：ArrayList数组实现；LinkedList双向链表实现\n适用场景：ArrayList适用于频繁的查找；LinkedList适用于频繁的增加和删除\n空间连续性：ArrayList必须开辟连续空间；LinkedList无须开辟连续空间\n快速随机访问性：ArrayList实现了RandomAccess接口，支持快速随机访问；LinkedList没有实现RandomAccess接口，不支持快速随机访问\n\nReferenceshttps://www.bilibili.com/video/BV1zD4y1Q7Fw?p=15\nhttps://www.runoob.com/java/java-arraylist.html\nhttps://www.yuque.com/apachecn/howtodoinjava-zh/docs_java_211\n","categories":["Java"],"tags":["集合框架"]},{"title":"Map实现类","url":"/2021/02/16/Map%E5%AE%9E%E7%8E%B0%E7%B1%BB/","content":"本篇介绍了Map实现类中的HashMap、LinkedHashMap、TreeMap、Hashtable和ConcurrentHashMap\n\nHashMapHashMap是Java1.2引入的一种基于哈希表的Map接口的非同步实现\n特点底层实现：基于哈希表（数组+链表+红黑树）\n允许null值的key和value，key不允许重复（故只能有一个null值），value允许重复（故可有多个null值）\n无序，即不保证插入映射的顺序，特别的，不保证该顺序随时间保持不变\n线程不安全\n分析具体见HashMap详解\n总结HashMap是最常用的Java集合之一，主要用来存放键值对。JDK1.8之前由数组加链表实现，JDK1.8之后引入了红黑树结构，当链表长度大于阈值（默认是8）时（且数组长度需要≥64，否则会先进行数组扩容），该桶处的链表就会转化为红黑树结构，从而进一步优化了搜索的时间效率\nLinkedHashMapLinkedHashMap是基于HashMap的双向链表实现\n特点底层实现：HashMap+双向链表\n通过双向链表结构来保证插入顺序和访问顺序\n线程不安全\n分析public class LinkedHashMap&lt;K,V&gt;    extends HashMap&lt;K,V&gt;    implements Map&lt;K,V&gt;\n可见，LinkedHashMap是HashMap的子类，直接继承自HashMap类\nstatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;    Entry&lt;K,V&gt; before, after;    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;        super(hash, key, value, next);    &#125;&#125;\nLinkedHashMap中存储元素的节点结构为Entry，继承自HashMap的Node\n其他方法的实现（诸如put、get、remove等）与HashMap大致类似，这里不再具体分析…\n总结HashMap是不保证插入映射的顺序的，而LinkedHashMap由于增加了双向链表结构，记录了节点的前后指针，因此相比于HashMap，LinkedHashMap能够保证映射的插入顺序和访问顺序。其他方法的逻辑与HashMap大致类似，且都是线程不安全的\nTreeMapTreeMap是基于红黑树实现的一个有序Map\n特点底层实现：红黑树\n可实现按Key对元素排序，相应的，Key必须实现Comparable接口\n与LinkedHashMap一样，TreeMap也能保证集合元素的顺序性\n特别的，默认的TreeMap的Key值不能为null，否则会抛出NullPointerException异常\n线程不安全\n分析public class TreeMap&lt;K,V&gt;    extends AbstractMap&lt;K,V&gt;    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable\n可见，TreeMap和HashMap一样，继承自AbstractMap类。不同的是，TreeMap还实现了NavigableMap接口\npublic interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt;\nNavigableMap接口具有对集合内元素检索的能力\npublic interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt;&#123;    Comparator&lt;? super K&gt; comparator();    //...&#125;\nNavigableMap接口继承自SortedMap接口，SortedMap存储的是有序的键值对，内部维护了一个Comparator比较器，可以对Key自动排序（默认升序）\n总结TreeMap相比于HashMap，最大的区别就是可实现按Key排序，相应的要求TreeMap中的Key必须实现Comparable接口，且Key值不能为null\n由于TreeMap底层是用红黑树实现的，维护一个红黑树的操作比较复杂，代价也相应较大，所以TreeMap不适合用于频繁修改的场景\nHashtableHashtable与HashMap很相似，区别是Hashtable作为原始的java.util的一部分，实现了同步\n特点底层实现：数组+链表\n区别于HashMap，Hashtable不允许有null值的key和value\nHashtable内部的方法基本都用了synchronized 修饰，所以是线程安全的\n分析public class Hashtable&lt;K,V&gt;    extends Dictionary&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable\n对比HashMap，Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类，两者实现的接口都是一样的\npublic Hashtable() &#123;    this(11, 0.75f);&#125;\n对比HashMap，Hashtable的默认初始容量为11，而HashMap的默认初始容量为16，默认的负载因子都为0.75\nprotected void rehash() &#123;\t//...    int newCapacity = (oldCapacity &lt;&lt; 1) + 1;    //...&#125;\nrehash()是Hashtable的扩容方法，可见，Hashtable扩容机制是旧容量的两倍加一，而HashMap是两倍扩容\n总结Hashtable是早期的一种集合类，初期设计使得它内部的方法几乎都实现了同步，这对效率来说是很致命的，因此现在不推荐使用Hashtable，要想保证程序的线程安全，推荐使用ConcurrentHashMap\n顺带一提，Hashtable为什么不符合驼峰命名呢？那是因为Hashtable诞生得太早了，Java1.0的时候就出现了，而集合的规范命名是在Java2之后才约定的，那为什么不在后续的版本中修订它呢？可能是因为已经不推荐使用Hashtable了，所以干脆就让它不那么规范(¬‿¬)\n还可能是为了考虑使用旧版本JDK的系统的兼容性吧。总而言之，就是不要再使用Hashtable了\nConcurrentHashMap为了在并发环境下，能够兼顾线程安全和运行效率，ConcurrentHashMap应运而生\n特点底层实现：\n\nJDK1.8之前：Segment数组+HashEntry数组+链表\n\nJDK1.8之后：Node数组+链表+红黑树\n\n\n线程安全性：只锁住当前桶，锁的粒度更小\n所谓锁的粒度，就是指锁细化的程度，锁的粒度越大，并发性越低且开销大；锁的粒度越小，并发性越高且开销小\n对比Hashtable实现线程安全的方式，是对整个集合锁住，锁的粒度更大\n分析之后再具体写一篇关于ConcurrentHashMap的详细分析，待补充…\n总结ConcurrentHashMap的实现在JDK1.8前后区别比较大，JDK1.8之前，底层实现是Segment数组+HashEntry数组+链表，每一个Segment都是一个类似于HashMap的结构，且Segment数组一旦初始化就不可扩容了。JDK1.8之前实现线程安全性的方式是分段锁，即对每一个Segment锁住。在JDK1.8之后，ConcurrentHashMap的底层实现变成了Node数组+链表+红黑树，实现线程安全性的机制也变成了CAS+Synchronized，进一步细化了锁的粒度\n总结HashMap：常用的存储键值对的集合，但是不保证顺序且线程不安全\nLinkedHashMap：借助了双向链表结构保证了插入顺序和访问顺序\nTreeMap：基于红黑树，保证有序性的同时，还实现了元素的排序\nHashtable：旧时代的余孽，尽管线程安全，但效率低下，已经被淘汰了\nConcurrentHashMap：兼顾线程安全和运行效率，多线程环境下推荐使用\n","categories":["Java"],"tags":["集合框架"]},{"title":"Raspberry Pi 3b 安装 Arch Linux ARM","url":"/2018/10/29/RasPi-3b-%E5%AE%89%E8%A3%85arch-Linux-arm/","content":"记录下树莓派3b初体验，在树莓派上安装Arch Linux并连接笔记本显示\n\n准备工具\n树莓派\nsd卡、读卡器\n网线\n电源线\n\n烧录系统首先是要将树莓派要使用的系统烧录进sd卡，这里选择的是arch Linux arm\n\nArch Linux ARM著名轻量系统Arch Linux在ARM架构上的移植。注重对于开发者的简洁，任何可有可无的软件一律不自带。仅有命令行界面，不建议初学者使用。Arch Linux的软件策略是相当激进的，使用Arch Linux能用到最新的软件包，但也需要承担尝鲜可能的风险。\n\n正好之前在虚拟机里装好了manjaro系统，manjaro也是一款基于arch Linux的系统。现在只需要将sd卡连入manjaro，然后将系统烧录进sd卡即可。\n\n注意虚拟机对usb3.0的兼容性普遍来说不太好，刚开始使用3.0接口的读卡器插入，出现设备在本机和虚拟机交替识别的情况，导致识别冲突无法正常使用。尝试之后发现2.0接口的不会出现这种情况。\n\nsd卡分区$ sudo fdisk -l\t#列出所有分区表\n找到sd卡盘符对应的设备名sdx（这里是sdb1）\n$ sudo fdisk /dev/sdb1\n在fdisk提示命令下进行下列操作：o\t#删除全部分区n\t#新建分区p\t#选择为主分区，接下来的主分区设置直接回车使用默认值，最后输入+100M设置结束tc\t#设置刚才的主分区类型为W95 FAT32（LBA）np2\t#选择第2个分区，然后回车使用默认值完成第2个分区的设置w\t#写入保存，退出fdisk\n挂载与安装\n挂载：把硬盘设备与某个目录相关联，关联的动作为挂载\n\n将第1分区格式化并挂载到boot$ mkfs.vfat /dev/sdb1$ mkdir boot$ mount /dev/sdb1 boot\n将第2分区格式化并挂载到root$ mkfs.ext4 /dev/sdb2$ mkdir root$ mount /dev/sdb2 root下载arch Linux arm系统并解压到sd卡$ wget https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/os/ArchLinuxARM-rpi-3-latest.tar.gz$ sudo tar -xzvpf ArchLinuxARM-rpi-3-latest.tar.gz -C root$ sync$ sudo mv root/boot/* boot$ sudo umount boot root\n树莓派连接笔记本将烧录好系统的sd卡插入树莓派然后启动树莓派，笔记本上设置好WiFi网络共享，然后通过网线连接树莓派和笔记本。\n\n注意树莓派系统正常启动的话，电源红灯旁边会有一个绿色的灯亮起，若启动树莓派时绿灯未亮，则表明树莓派未启动系统，可能是之前烧录系统出错。\n\nssh连接这里选择了一个ssh连接工具：Xshell默认的用户名为alarm，密码为root树莓派每次启动都会有一个ip，在命令行工具中输入arp -a查看并找到对应ip地址登录连接即可\n改源更新安装改源$ su root\t#切换成管理员$ vi /etc/pacman.d/mirrorlist将mirrorlist内容更换为Server &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinuxarm&#x2F;$repo&#x2F;os&#x2F;$arch\n更新软件源$ pacman -Syyu\n安装sudo$ pacman -S sudo安装sudo时报错信息warning: Public keyring not found; have you run &#x27;pacman-key --init&#x27;?解决措施$ pacman-key --init$ pacman -S sudo继续报错error: failed to commit transaction (invalid or corrupted package (PGP signature))解决措施$ pacman-key --populate$ pacman -S sudo\t#成功\n安装screenfetch$ pacman -S screenfetch\n","categories":["硬件"],"tags":["树莓派","Arch Linux"]},{"title":"Servlet基础","url":"/2019/05/12/Servlet%E5%9F%BA%E7%A1%80/","content":"Server Applet，即用Java编写的服务端程序，用来处理请求的业务逻辑\n\n什么是Servletservlet本质上就是一个Java接口，定义的是一套处理网络请求的规范。servlet不会直接和客户端打交道，请求是通过servlet容器来传递的，常用的servlet容器有tomcat，容器监听端口后将请求信息交给servlet来处理，servlet再调用service()方法返回response对象给容器，容器再将这个response返回给客户端，使用servlet是来实现浏览器与服务器的交互的。\nGenericServlet 与HttpServletGenericServlet抽象类实现了Servlet和ServletConfig接口，并完成了以下任务：\n\n将init方法中的ServletConfig赋给一个类级变量，以便可以通过调用getServletConfig获取\n为Servlet接口中的所有方法提供默认的方法\n提供方法，包括ServletConfig中的方法\n\n简而言之，GenericServlet是一个通用的协议无关的Servlet，它实现了除了service()之外的其他方法，在创建Servlet对象时，可以继承GenericServlet类来简化程序的代码，但需要实现service()方法。\n但是，用得最广泛的还是HttpServlet，它更加适用于http协议\nHttpServlet类继承自GeneriServlet类，它的主要特性有：\n\n不用覆盖service方法，而是覆盖doGet和doPost。在少数情况下，还会覆盖以下任意方法：doHead、doPut、doTrace、doOptions、doDelete\n使用HttpServletRequest和HttpServletResponse，而不是ServletRequest和ServletResponse\n\n生命周期\n加载和实例化。Tomcat第一次访问servlet时，Tomcat负责创建servlet的实例\n\n初始化。servlet被实例化后，Tomcat调用servlet的init()方法初始化对象\n\n处理请求。浏览器访问servlet时，servlet调用service()方法处理请求\n\n销毁。调用destroy()，释放掉实例占用的资源\n每访问一次servlet，就会调用service()，而init()在被销毁前只有第一次访问时被调用。\n\n\nxml配置文件  由于servlet是要实现浏览器与服务器交互的，所以Tomcat容器还要知道浏览器怎么访问servlet。从Servlet3.0开始，配置servlet有两种方式：\n\n在servlet类中使用基于注解的方式进行配置，即@WebServlet\n\n使用部署描述符，即web.xml文件\n&lt;servlet&gt;    &lt;!-- 为servlet配置名字[一般与类名一致] --&gt;    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;    &lt;!-- 类的存放位置信息[包含包名] --&gt;    &lt;servlet-class&gt;com.con.MyServlet&lt;/servlet-class&gt;    &lt;!-- 在web应用程序启动时就装载并创建该servlet实例对象，以及调用它的init()方法，例如为整个web应用创建数据库 --&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- 配置映射路径 --&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;    &lt;!-- url链接路径--&gt;    &lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n\n  过程：\n\n\n访问url链接    &lt;url-pattern&gt;     同一个Servlet可以被映射到多个URL上\n找到web.xml配置信息中的映射路径名字    &lt;servlet-name&gt;\n通过映射路径名字找到配置servlet的名字    &lt;servlet-name&gt;\n通过servlet的名字找到servlet编译后class文件存放的位置    &lt;servlet-class&gt;\n执行程序\n\n\nServletConfigServletConfig对象的作用：用于封装servlet的配置信息，读取web.xml中配置的初始化参数\n将参数信息放在web.xml文件中的好处：使程序更加灵活，当需要更换参数时，只需更新配置文件web.xml，而不用改程序代码\n  &lt;servlet&gt;    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.MyServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;name&lt;/param-name&gt;        &lt;param-value&gt;value&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\nServletContext每当容器Tomcat启动时，都会创建一个ServletContext对象，它代表当前web站点\n  &lt;context-param&gt;    &lt;param-name&gt;username&lt;/param-name&gt;    &lt;param-value&gt;Piccolo_Devil&lt;/param-value&gt;&lt;/context-param&gt;\n作用：\n\n所有Servlet共享一个ServletContext对象，ServletContext可以获取的是整个web站点的配置信息，所以可以通过ServletContext实现不同Servlet之间的通讯。\n//Servlet AServletContext context = this.getServletContext();context.setAttribute(&quot;username&quot;,&quot;Piccolo_Devil&quot;);\t//向域对象中存入name-value数据//Servlet BServletContext context = this.getServletContext();String value=(String) context.getAttribute(&quot;username&quot;);\t//获取域中属性System.out.println(value);\n\n获取整个web应用的配置信息\nString url = this.getServletContext().getInitParameter(&quot;url&quot;);String username = this.getServletContext().getInitParameter(&quot;username&quot;);String password = this.getServletContext().getInitParameter(&quot;password&quot;);\n\n实现servlet转发\nthis.getServletContext().setAttribute(&quot;data&quot;,&quot;serlvet数据转发&quot;);RequestDispatcher rd = this.getServletContext().getRequestDispatcher(&quot;/viewdata.jsp&quot;);rd.forward(request, response);\n读取资源文件\n一般读取文件的时候，如果程序和文件在同一包名下，可以直接通过文件名称获取文件，因为这个程序是通过JVM来运行的，而在servlet技术中，是通过容器如Tomcat来运行的，Servlet编译后的class文件是存放在WEB-INF目录下的classes文件夹中，这样读取时的路径要写上绝对路径。这会带来很多不便，而且不同站点的绝对路径也会有差异。这时就可以通过ServletContext对象来获取文件路径。\nServletContext servletContext = this.getServletContext();//调用ServletContext方法获取到读取文件的流InputStream inputStream = servletContext.getResourceAsStream(&quot;/WEB-INF/classes/com/web/1.png&quot;);\n\n\n","categories":["Java"],"tags":["Servlet"]},{"title":"Set实现类","url":"/2021/02/16/Set%E5%AE%9E%E7%8E%B0%E7%B1%BB/","content":"本篇介绍了Set实现类中的HashSet、LinkedHashSet和TreeSet\n\nHashSet特点底层实现：基于HashMap（数组+链表+红黑树）\n无序、不重复，允许有null值（只能有一个null）\n线程不安全\n分析HashSet继承AbstractSet类，实现了Set、Cloneable、Serializable接口\npublic class HashSet&lt;E&gt;    extends AbstractSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123;    //可见，HashSet底层是使用HashMap来存储数据的    private transient HashMap&lt;E,Object&gt; map;    //构造方法也都是借助于HashMap来实现的    public HashSet() &#123;        map = new HashMap&lt;&gt;();    &#125;\t//...&#125;\n存储过程也可理解为HashSet如何检查重复元素\n\n计算对象的hashCode值来判断对象应该加入的位置，若该位置为空（即与其他对象的hashCode值不同），则直接加入\n若该位置已经存储了其他对象（即hashCode值相同），则再调用equals()方法来检查两个对象是否相同，若不同，则添加到对应位置的链表上；若是重复对象，则不添加\n\n在使用时需要重写hashCode()方法和equals()方法\nLinkedHashSet特点底层实现：继承于HashSet，其实底层使用的是LinkedHashMap（HashMap+双向链表）\n在HashSet的基础上，双向链表结构维护了插入的顺序\n线程不安全\n分析public class LinkedHashSet&lt;E&gt;    extends HashSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable\n继承自HashSet，实现了Set、Cloneable、Serializable接口\npublic LinkedHashSet(int initialCapacity, float loadFactor) &#123;    super(initialCapacity, loadFactor, true);&#125;public LinkedHashSet(int initialCapacity) &#123;    super(initialCapacity, .75f, true);&#125;public LinkedHashSet() &#123;    super(16, .75f, true);&#125;public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;    super(Math.max(2*c.size(), 11), .75f, true);    addAll(c);&#125;\nLinkedHashSet的四种构造方法，发现都是调用的父类HashSet的构造方法\nHashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125;\n发现实际上底层实现还是LinkedHashMap\nTreeSet特点底层实现：基于TreeMap（红黑树）\n元素不重复、有序\n可自定义排序，需实现Comparable接口并重写compareTo方法\n线程不安全\n分析public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable\n实现了NavigableSet接口\npublic interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt;\nNavigableSet接口继承自SortedSet接口，内部维护了一个Comparator比较器，可实现元素的有序性\nTreeSet(NavigableMap&lt;E,Object&gt; m) &#123;    this.m = m;&#125;public TreeSet() &#123;    this(new TreeMap&lt;E,Object&gt;());&#125;public TreeSet(Comparator&lt;? super E&gt; comparator) &#123;    this(new TreeMap&lt;&gt;(comparator));&#125;public TreeSet(Collection&lt;? extends E&gt; c) &#123;    this();    addAll(c);&#125;public TreeSet(SortedSet&lt;E&gt; s) &#123;    this(s.comparator());    addAll(s);&#125;\n可见，TreeSet的构造方法底层实现是借助于TreeMap，然后指向NavigableMap类型的引用\n总结HashSet：基于HashMap，无序、不重复\nLinkedHashSet：基于LinkedHashMap，有序、不重复，双向链表结构保证了有序性\nTreeSet：基于TreeMap，有序、不重复、可排序，红黑树结构保证有序性的同时还能实现排序\n","categories":["Java"],"tags":["集合框架"]},{"title":"C/C++环境搭建","url":"/2021/01/01/c-cpp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"本篇介绍了如何在Windows系统下搭建C/C++开发环境，并对一些概念进行了较详细的解释\n\nC语言环境搭建\nC编译器\n 一个现代编译器的主要工作流程：源代码（source code）→ 预处理器（preprocessor）→ 编译器（compiler）→ 汇编程序（assembler）→ 目标代码（object code）→ 链接器（linker）→ 可执行文件（executables），最后打包好的文件就可以给电脑去判读运行了。\n\nGNUGNU’s Not Unix. GNU is an extensive collection of free software, which can be used as an operating system or can be used in parts with other operating systems. The use of the completed GNU tools led to the family of operating systems popularly known as Linux. Most of GNU is licensed under the GNU Project’s own General Public License.\n\nUnix 系统被发明之后，大家用的很爽。但是后来开始收费和商业闭源了。一个叫 RMS 的大叔觉得很不爽，于是发起 GNU 计划，模仿 Unix 的界面和使用方式，从头做一个开源的版本。然后他自己做了编辑器 Emacs 和编译器 GCC。GNU 是一个计划或者叫运动。在这个旗帜下成立了 FSF，起草了 GPL 等。接下来大家纷纷在 GNU 计划下做了很多的工作和项目，基本实现了当初的计划。包括核心的 gcc 和 glibc。但是 GNU 系统缺少操作系统内核。原定的内核叫 HURD，一直完不成。同时 BSD（一种 UNIX 发行版）陷入版权纠纷，x86 平台开发暂停。然后一个叫 Linus 的同学为了在 PC 上运行 Unix，在 Minix 的启发下，开发了 Linux。注意，Linux 只是一个系统内核，系统启动之后使用的仍然是 gcc 和 bash 等软件。Linus 在发布 Linux 的时候选择了 GPL，因此符合 GNU 的宗旨。最后，大家突然发现，这玩意不正好是 GNU 计划缺的么。于是合在一起打包发布叫 GNU / Linux。然后大家念着念着省掉了前面部分，变成了 Linux 系统。摘自知乎匿名用户\n\nGCCThe GNU Compiler Collection (GCC) is a compiler system produced by the GNU Project supporting various programming languages. GCC is a key component of the GNU toolchain and the standard compiler for most projects related to GNU and Linux, including the Linux kernel. \nThe GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Ada, Go, and D, as well as libraries for these languages (libstdc++,…). GCC was originally written as the compiler for the GNU operating system.\ngcc与g++：\ngcc作为GNU项目的编译器，早期只是GUN C Compiler，即C编译器。后来由于项目的发展，gcc中集成了其他不同语言的编译器。于是gcc也就成了GNU Compiler Collection，即不同语言编译器的合集。而g++即是gcc中的c++编译器。\n举个例子：你便写了一段程序，代码后缀命名为.c，那么它会调用gcc中的c编译器和linker去链接c的library。如果代码后缀为.cpp，则调用g++编译器，并且linker链接c++的library。\nWindows下的GCC\nReference：https://my.oschina.net/wqli/blog/544340\n\n一般我们不会只使用gcc一个工具，而是希望使用和它相关的一套工具，例如g++, gdb等，称为工具链（toolchain）。在Windows下包含GCC移植版本的主要有 MinGW 和 Cygwin 两个流派。\n\nCygwin - 其实并不是一个GCC。它是让Windows拥有Unix-like环境的软件，所以，GCC自然也就会包含在里面（注意这里面的GCC和Linux下的GCC是一样的）。不过，对于开发者，Cygwin是一个开发环境。而对于用户来说Cygwin是一个运行环境。使用Cygwin可以在Windows下调用Unix-like的系统函数，比如进程函数。\nMinGW - Minimalist GNU for Windows，可看作Windows应用的极简开发环境，提供的开源工具集不依赖于第三方DLL（但会依赖于微软官方库），主要包含GNU GCC编译器的移植版，MSYS以及其他工具。其中的MSYS是一个Bash Shell，可用来代替cmd.exe与MinGW工具一块使用。MinGW支持几乎所有Win32API，确实像是VS的一个替代品。可以从MinGW的官网找到其初始安装包，在安装时选择需要的工具下载安装。\nMinGW-w64 - 是MinGW的增强版，开始于2007年。原来的MinGW只能开发32位windows程序，而这个可以开发32位和64位程序，并加入了一系列增强工具。\nTDM-GCC - 可用来替代MinGW，它使用最新的GCC稳定版工具集，并且容纳了 MinGW 和 MinGW-w64，能够创建32位和64位程序。简单的说就是，TDM-GCC是包含GCC编译器，MinGW运行时API等很多开源工具的发行套装，只需要下载一个安装文件即可。\nMSYS2 - 其中的MSYS表示Minimal SYStem，不过它独立于MSYS开发，基于Cygwin和MinGW-w64，提供了一个bash shell，版本控制（git），MinGW-w64编译环境，以及众多的Unix/Linux环境下的工具。\n\n安装Mingw-w64\n下载windows版本的Mingw-w64安装器\n\nArchitecture(架构)选项中选择x86_64，其他按引导安装\n\n将mingw64的bin路径添加到系统环境变量，默认安装路径则路径为：\n\nC:\\Program Files\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\bin\n\n\n验证安装是否成功：cmd，gcc -v\n\n\n文本编辑器VSCode\nC/C++插件\nC/C++\nChinese (Simplified) Language Pack for Visual Studio Code\nCode Runner\nvscode-icons\nBeautify\n\n.vscode文件夹Launch configurations\nTo run or debug a simple app in VS Code, select Run and Debug on the Debug start view or press F5 and VS Code will try to run your currently active file.\nHowever, for most debugging scenarios, creating a launch configuration file is beneficial because it allows you to configure and save debugging setup details. VS Code keeps debugging configuration information in a launch.json file located in a .vscode folder in your workspace (project root folder) or in your user settings or workspace settings.\n&#123;    // 使用 IntelliSense 了解相关属性。     // 悬停以查看现有属性的描述。    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;(gdb) Launch&quot;, //配置名称，显示在启动配置的下拉菜单中            &quot;type&quot;: &quot;cppdbg&quot;,   //配置类型，cppdbg对应为cpptools提供的调试功能            &quot;request&quot;: &quot;launch&quot;,    //请求配置类型，可以为launch（启动）或attach（附加）            &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;, //需要进行调试的程序路径            &quot;args&quot;: [], //程序调试时传递给程序的命令行参数，一般设为空即可            &quot;stopAtEntry&quot;: false,   //设为true时程序将暂停在程序入口处，相当于在main上打断点            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,//调试程序时的工作目录，此为工作区文件夹；改成$&#123;fileDirname&#125;可变为文件所在目录            &quot;environment&quot;: [],  //环境变量            &quot;externalConsole&quot;: true,   //使用单独的cmd窗口，与其它IDE一致；为false时使用内置终端            &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？            &quot;MIMode&quot;: &quot;gdb&quot;,    //指定连接的调试器，可以为gdb或lldb。但我没试过lldb            &quot;miDebuggerPath&quot;: &quot;C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\gdb.exe&quot;,   //调试器路径，Windows下后缀不能省略，Linux下则不要            &quot;setupCommands&quot;: [  //模板自带，好像可以更好地显示STL容器的内容，具体作用自行Google                &#123;                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                &#125;            ],            &quot;preLaunchTask&quot;: &quot;Compile&quot; // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应        &#125;    ]&#125;\nTasks configurations\nTasks in VS Code can be configured to run scripts and start processes so that many of these existing tools can be used from within VS Code without having to enter a command line or write new code. Workspace or folder specific tasks are configured from the tasks.json file in the .vscode folder for a workspace.\n&#123;    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [&#123;        &quot;label&quot;: &quot;Compile&quot;, // 任务名称，与launch.json的preLaunchTask相对应        &quot;command&quot;: &quot;g++&quot;,   // 要使用的编译器，C++用g++        &quot;args&quot;: [            &quot;$&#123;file&#125;&quot;,            &quot;-o&quot;,    // 指定输出文件名，不加该参数则默认输出a.exe，Linux下默认a.out            &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,            &quot;-g&quot;,    // 生成和调试有关的信息            &quot;-m64&quot;, // 不知为何有时会生成16位应用而无法运行，加上此条可强制生成64位的            &quot;-Wall&quot;, // 开启额外警告            &quot;-static-libgcc&quot;,     // 静态链接libgcc，一般都会加上            &quot;-fexec-charset=GBK&quot;, // 生成的程序使用GBK编码，不加这条会导致Win下输出中文乱码；繁体系统改成BIG5            &quot;-std=c++14&quot;, // 要用的语言标准，根据自己的需要修改。c++可用c++14，c11        ], // 编译的命令，其实相当于VSC帮你在终端中输了这些东西        &quot;type&quot;: &quot;process&quot;, // process是把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍        &quot;group&quot;: &#123;            &quot;kind&quot;: &quot;build&quot;,            &quot;isDefault&quot;: true // 不为true时ctrl shift B就要手动选择了        &#125;,        &quot;presentation&quot;: &#123;            &quot;echo&quot;: true,            &quot;reveal&quot;: &quot;always&quot;, // 执行任务时是否跳转到终端面板，可以为always，silent，never。具体参见VSC的文档            &quot;focus&quot;: false,     // 设为true后可以使执行task时焦点聚集在终端，但对编译C/C++来说，设为true没有意义            &quot;panel&quot;: &quot;new&quot;   // shared:不同的文件的编译信息共享一个终端面板;new:每个进程创建新的端口        &#125;,        &quot;problemMatcher&quot;:&quot;$gcc&quot; // 捕捉编译时终端里的报错信息到问题面板中，修改代码后需要重新编译才会再次触发        // 本来有Lint，再开problemMatcher就有双重报错，但MinGW的Lint效果实在太差了；用Clang可以注释掉    &#125;]&#125;\nc_cpp_properties\n&#123;    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;Win32&quot;,            &quot;includePath&quot;: [                &quot;$&#123;workspaceFolder&#125;/**&quot;            ],            &quot;defines&quot;: [                &quot;_DEBUG&quot;,                &quot;UNICODE&quot;,                &quot;_UNICODE&quot;            ],            &quot;compilerPath&quot;: &quot;C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe&quot;,            &quot;cStandard&quot;: &quot;c11&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;,            &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;        &#125;    ],    &quot;version&quot;: 4&#125;","categories":["C"],"tags":["C","C++"]},{"title":"Hexo+Github搭建个人博客","url":"/2018/10/05/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"记录搭建hexo博客网站的详细过程\n\n一、环境配置\nGit  关于windows下git的下载安装，可以选择直接官网下载git，并使用git for windows自带的git bash来完成相关git命令的执行。也可以先下载安装msys2，利用msys2提供的bash完成git的安装以及相关git命令的执行。\n\nNodejs官网下载好nodejs后安装即可。然后是配置nodejs。找到C:\\Program Files\\nodejs\\node_modules\\npm目录（具体是你自己的安装路径）下的npmrc文件，打开并编辑成如下：  \ncwd      = D:\\nodejs\\npm\\homeprefix   = D:\\nodejs\\npmregistry = http://registry.npm.taobao.org/HOME     = D:\\nodejs\\npm\\home\n然后将D:\\nodejs\\npm添加到系统path中。\n\nhexo\n  $ npm install -g hexo\n\ngithub  首先你要有一个github账号，然后创建repository，repository的名字是username.github.io(username是你账号的username，这个仓库名字就是搭建成功后博客的域名，所以尽量不要有一些奇怪的username)。\n\n\n二、搭建博客\n创建个人博客文件夹 在任意地方(如D盘根目录下)创建一个新的文件夹，以保存个人博客的相关文件。\n $ hexo init myblog\t#初始化\n 提示成功后，发现选择的目录下多出了一个myblog文件夹，并且配置好了hexo的相关文件。\n\n安装依赖包 $ npm install\n本地查看博客页面\n $ hexo g\t#生成$ hexo s\t#启动服务预览\n 然后访问 http://localhost:4000/ 就能看到个人博客的页面了。\n\n\n三、本地git项目与github联动\nSSH：简单来说就是一种加密的网络协议(Secure Shell)\n\n\n检查本机SSH Key的设置\n $ cd ~/.ssh\n 显示“No such file or directory”，则进行下一步\n\n生成新的SSH Key\n $ ssh-keygen -t rsa -C &quot;注册github的邮箱地址&quot;\n 期间按一次回车，输入两次密码即可。 设置的密码是提交项目时的密码，防止别人往项目里乱提交东西。\n\n将SSH Key添加到Github 找到id_rsa.pub文件，打开后复制文件里的内容。 打开github主页，找到Settings，选择SSH and GPG keys，New SSH key，Title随便取一个名字(如：blog)，Key中粘贴刚才文件里的内容，Add SSH key。\n\n测试\n $ ssh -T git@github.com\n 期间输入yes回车，输入之前设置的密码回车。\n\n\n四、博客配置\n根目录下的博客配置文件_config.yml\n\n\n\n推送到github\n  $ npm install hexo-deployer-git --save\n  这个操作是为了将我们写的文章部署到github服务器上并可以被别人浏览。\n\n发布\n  $ hexo d -g\t\t#生成和部署\n  期间会弹出github的登录窗口，输入登录即可。\n\nOK  到此，我们的个人博客就算是搭建好了，访问 https://username.github.io/ 就能看到属于自己的博客空间了~\n\n\n","categories":["Blog"],"tags":["Hexo"]},{"title":"manjaro安装笔记","url":"/2018/10/17/manjaro%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/","content":"Manjaro是一款基于Arch Linux、对用户友好、全球排名第1的Linux发行版\nmanjaro xfce安装\n下载manjaro xfce镜像文件\n​    https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/archive/17.1.7/xfce/\n\n虚拟机安装manjaro，注意版本选择其他 Linux4.x 或更高版本内核 64位，还有注意的一点是内存至少选择2G，否则会卡在后续安装界面不动\n\n选择Boot之后，加载出桌面以及一个Manjaro的官方欢迎界面，选择Launch installer进行真正意义上的（傻瓜式）安装，完成后重启即可\n\n\n安装后的配置选择国内源并更新$ sudo pacman-mirrors -c China\n用vim编辑配置文件，在里面添加archlinuxcn源$ sudo vim /etc/pacman.config\n这时发现并没有安装vim，用pacman安装一下$ sudo pacman -S vim\n在pacman.config文件中添加下面语句[archlinuxcn]Server &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinuxcn&#x2F;$arch\n完成上面操作后,让本地的包数据库和远程的软件仓库同步$ sudo pacman -Syy\n安装archlinuxcn-keyring,提供校验软件包的密钥$ sudo pacman -S archlinuxcn-keyring同步软件库并更新系统到最新状态$ sudo pacman -Syu这时候出现了异常\n解决方案：$ sudo pacman -Qo /usr/lib/xfce4/thunar-archive-plugin/engrampa.tap$ sudo mv /usr/lib/xfce4/thunar-archive-plugin/engrampa.tap -vT /usr/lib/xfce4/thunar-archive-plugin/engrampa.tap.bak$ sudo pacman -Syu$ sudo rm -v /usr/lib/xfce4/thunar-archive-plugin/engrampa.tap.bak\n到此，改源和更新的基本配置就完成了。\n","categories":["Linux"],"tags":["manjaro"]},{"title":"Python3爬虫实例","url":"/2019/08/03/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/","content":"本篇简单介绍了爬虫技术，并实现了用python爬取小说网站的案例\n\n关于爬虫网络爬虫（Web Spider），把互联网比作是蜘蛛网，那么爬虫就是在蜘蛛网上爬来爬去的蜘蛛。爬虫通过网页的链接来寻找网页，从一个页面开始读取网页的内容，获取网页中的链接来寻找下一个网页，直到爬取完网站的所有网页。\n爬虫流程：\n\n先由urllib的request打开Url得到网页html文档\n\n浏览器打开网页源代码分析元素节点\n\n通过Beautiful Soup或则正则表达式提取想要的数据\n\n存储数据到本地磁盘或数据库（抓取，分析，存储）\n\n\n资源链接requests官方中文文档\nBeautifulSoup官方中文文档\n爬取小说网站此案例为爬取小说网站的小说资源，使用了BeautifulSoup，实现较为简单粗略\nfrom bs4 import BeautifulSoupimport sysimport requestsclass downloader(object):    def __init__(self):        &quot;&quot;&quot;设置初始化属性值&quot;&quot;&quot;        self.server = &#x27;http://www.biqukan.com/&#x27;    # 主站ip        self.target = &#x27;https://www.biqukan.com/1_1496/&#x27;    # 对应小说分站ip        self.names = []    # 章节名        self.urls = []    # 章节链接        self.nums = 0    # 章节数        self.headers = &#123;            &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Mobile Safari/537.36&quot;        &#125;    def get_download_url(self):        &quot;&quot;&quot;获取下载链接&quot;&quot;&quot;        req = requests.get(url=self.target, headers=self.headers)        # 要爬取的网页采用的编码方式是gbk        req.encoding = &#x27;GBK&#x27;        html = req.text        # 在解析html之前，我们需要创建一个Beautiful Soup对象        div_bf = BeautifulSoup(html, &#x27;lxml&#x27;)        # 获得html信息中所有class属性为showtxt的div标签，为避免关键字冲突，命名为class_        div = div_bf.find_all(&#x27;div&#x27;, class_=&#x27;listmain&#x27;)        a_bf = BeautifulSoup(str(div[0]), &#x27;lxml&#x27;)        # 查找&lt;a&gt;标签，提取它的href属性和里面存放的章节名        a = a_bf.find_all(&#x27;a&#x27;)        # 剔除不必要的章节，并统计章节数        self.nums = len(a[12:])        for each in a[12:]:            self.names.append(each.string)            self.urls.append(self.server + each.get(&#x27;href&#x27;))    def get_contents(self, target):        &quot;&quot;&quot;获取章节内容&quot;&quot;&quot;        req = requests.get(url=target, headers=self.headers)        req.encoding = &#x27;GBK&#x27;        html = req.text        bf = BeautifulSoup(html, &#x27;lxml&#x27;)        texts = bf.find_all(&#x27;div&#x27;, class_=&#x27;showtxt&#x27;)        # 去掉八个空格符号，并用回车代替        texts = texts[0].text.replace(&#x27;\\xa0&#x27;*8, &#x27;\\n&#x27;)        return texts    def writer(self, name, path, text):        &quot;&quot;&quot;将爬取的文章内容写入文件&quot;&quot;&quot;        # write_flag = True        with open(path, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as file:            file.write(name + &#x27;\\n&#x27;)            file.writelines(text)            file.write(&#x27;\\n\\n\\n\\n&#x27;)if __name__ == &quot;__main__&quot;:    dl = downloader()    dl.get_download_url()    print(&#x27;《圣墟》开始下载：&#x27;)    for i in range(dl.nums):        dl.writer(dl.names[i], &#x27;圣墟.txt&#x27;, dl.get_contents(dl.urls[i]))        sys.stdout.write(&quot;  已下载:%.3f%%&quot; % float(i/dl.nums*100) + &#x27;\\r&#x27;)        sys.stdout.flush()    print(&#x27;《圣墟》下载完成&#x27;)\n\n参考原文：https://blog.csdn.net/c406495762/article/details/78123502 \n","categories":["Python"],"tags":["Python","爬虫"]},{"title":"人工蜂群算法","url":"/2019/04/10/%E4%BA%BA%E5%B7%A5%E8%9C%82%E7%BE%A4%E7%AE%97%E6%B3%95/","content":"2005年由Karaboga小组为优化代数问题而提出，是一种基于群智能的全局优化算法\n\n组成要素\n食物源  蜜源，对应着问题的解\n雇佣蜂  采蜜蜂，一个雇佣蜂对应着一个食物源\n非雇佣蜂\n跟随蜂：跟随雇佣蜂选择食物源\n侦查蜂：随机寻找食物源\n\n\n\n算法流程\n初始化，构建图，点和边的预处理\n确定初始蜜源，将雇佣蜂与蜜源相关联\n雇佣蜂搜索蜜源邻域\n跟随蜂搜索蜜源邻域\n蜜源更新，迭代次数更新\n若跟随蜂无法搜索较优蜜源，则返回第3步重复过程；否则继续下一步\n侦查蜂全局搜索新蜜源\n更新蜜源，判断迭代是否溢出，未溢出返回第3步重复过程，溢出得到解\n\n概念拓展\n点度中心性\n\n举个例子，A的朋友圈有10个好友，相当于有10个结点和A相连，如果B的朋友圈有100个好友，那么就意味着B的点度中心性比A高。这是无向图的情形，若是有向图，则还需考虑入度和出度问题拓展，微博和微信是两个不同平台，若要比较A在微博的点度中心性和B在微信的点度中心性，这就需要考虑去规模化，这就是标准化的点度中心性理念\n\n接近中心性\n\n字面意思，接近中心性的值为路径长度的倒数，接近中心性需要考量每个结点到其它结点的最短路的平均长度，对于一个结点而言，它距离其它结点越近，那么它的中心度越高\n\n中介中心性\n\n中介，起到一种搭桥作用，指的是一个结点担任其它两个结点之间最短路的桥梁的次数。一个结点充当“中介”的次数越高，它的中介中心度就越大。如果要考虑标准化的问题，可以用一个结点承担最短路桥梁的次数除以所有的路径数量\n","categories":["数学建模"]},{"title":"初识C指针","url":"/2018/10/26/%E5%88%9D%E8%AF%86C%E6%8C%87%E9%92%88/","content":"了解C语言指针的基本概念和使用方法\n\n一、什么是指针从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，而指针类型变量的值是地址。类比一下，c语言的数组，它本身是一种类型，但具体又可以区分为int型数组、double型数组、char型数组等；同理指针本身是一种数据类型，但根据它的指向，又有int型指针、double型指针、char型指针等。其实数组声明后得到的那个变量就是指针变量。计算机的硬件指令非常依赖地址，指针在某种程度上把想传达的指令以更接近机器的方式表达，因此使用指针能够使程序更加高效（但也可能会带来更多的麻烦）。\n二、指针的基本概念与使用#include&lt;stdio.h&gt;void exchange(int *a, int *b);\t//函数原型void swap(int a, int b)\t//函数定义&#123;    int temp = a;    a = b;    b = temp;&#125;int main()&#123;    int x = 5, y = 10;    printf(&quot;before:\\nx = %d\\ty = %d\\n&quot;, x, y);    exchange(&amp;x, &amp;y);\t//传递的是地址    printf(&quot;after:\\nx = %d\\ty = %d\\n&quot;, x, y);    int m = 2, n = 6;    printf(&quot;before:\\nm = %d\\tn = %d\\n&quot;, m, n);    swap(m,n);    printf(&quot;after:\\nm = %d\\tn = %d\\n&quot;, m, n);    int *p;\t//声明一个指向int类型的指针（指针变量记得初始化，否则野指针带来的问题很大    p = &amp;x;\t//p指向x    printf(&quot;p = %d\\n&quot;, p);    printf(&quot;*p = %d\\n&quot;, *p);\t//间接运算符*，也称解引用运算符，找出指针指向的值    return 0;&#125;void exchange(int *a, int *b)\t//a的值是&amp;x，a指向x，*a可以表示x的具体值&#123;    int temp;    temp = *a;\t//因为要交换的是数值而不是地址，所以temp = *a    *a = *b;    *b = temp;&#125;\n三、指针和数组数组名是数组首元素的地址#include&lt;stdio.h&gt;int main()&#123;    int day[12] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;    if(day == &amp;day[0])    &#123;        for(int i = 0; i &lt; 12; i++)        &#123;            printf(&quot;Month %2d has %d days.\\n&quot;, i + 1, *(day + i));            //day是数组首元素地址，day+i是元素day[i]的地址        &#125;    &#125;    return 0;&#125;实际上，C语言标准在描述数组表示法时确实借助了指针，也就是说，定义day[n]的意思就是(day+n)。可以认为(day+n)的意思是“到内存的day位置，然后移动n个单元，检索储存在那里的值“。\n四、指针操作#include&lt;stdio.h&gt;int main()&#123;    int arr[5] = &#123;100, 200, 300, 400, 500&#125;;    int *ptr1, *ptr2, *ptr3;    ptr1 = arr;    ptr2 = &amp;arr[2];    printf(&quot;ptr1 = %p, *ptr1 = %d, &amp;ptr1 = %p\\n&quot;, ptr1, *ptr1, &amp;ptr1);    ptr3 = ptr1 + 4;    printf(&quot;ptr1 + 4 = %p,*(ptr1 + 4) = %d\\n&quot;, ptr1 + 4, *(ptr1 + 4));    ptr1++;    printf(&quot;ptr1 = %p, *ptr1 = %d, &amp;ptr1 = %p\\n&quot;, ptr1, *ptr1, &amp;ptr1);    ptr2--;    printf(&quot;ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\\n&quot;, ptr2, *ptr2, &amp;ptr2);    --ptr1;    ++ptr2;    printf(&quot;ptr1 = %p, ptr2 = %p\\n&quot;, ptr1, ptr2);    printf(&quot;ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\\n&quot;, ptr2, ptr1, ptr2 - ptr1);    printf(&quot;ptr3 = %p, ptr3 - 2 = %p\\n&quot;, ptr3, ptr3 - 2);    return 0;&#125;","categories":["C"],"tags":["C"]},{"title":"单例模式","url":"/2019/07/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"本篇介绍了设计模式中的单例模式，单例对象的类有且仅有一个实例存在\n\n单例模式简介单例模式（Singleton Pattern）是Java设计模式之一，提供了一种创建对象的方式。在系统运行期间，有且仅有一个实例。\n单例模式需满足的条件：1. 一个类只有一个实例2. 自身创建自身的实例3. 向系统中其他对象提供自身实例\n单例模式的简单实现package Demo; import java.io.IOException;import java.io.InputStream;import java.util.Properties; /** *  单例模式 *  负责读取数据库连接信息 * */public class ConfigManager &#123;    private static ConfigManager configManager;      private static Properties properties;     /**     *  私有构造函数，执行在整个程序运行期间只需要进行一次的操作     * */    private ConfigManager()&#123;        properties=new Properties();        /**        *  首先，获得&quot;对象当前的类类型&quot;        *  而后在类类型上调用getClassLoader()方法是得到&quot;当前类型的类加载器&quot;        *  最后调用了类加载器的getResourceAsStream()方法来&quot;加载资源&quot;        * */        InputStream inputStream=ConfigManager.class.getClassLoader().getResourceAsStream(&quot;data.properties&quot;);        try &#123;            properties.load(inputStream);            inputStream.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;      /**     *  对外公开的方法     * */    public static ConfigManager getInstance()&#123;        if (configManager==null)            configManager=new ConfigManager();  //自身创建自身的实例        return configManager;    &#125;      /**     *  返回读取到的值     * */    public static String getValue(String key)&#123;        return properties.getProperty(key);    &#125;&#125;\n代码解读：1、一个类只有一个实例提供私有的构造函数，保证不能随意创建该类的实例。并且在构造函数中执行了读取配置文件的操作，这样就保证了I/O操作只执行一次\n2、自身创建自身的实例意味着必须提供一个实例并由它自身创建，所以我们定义了一个ConfigManager类型的静态变量，以便向外界提供实例时使用\n3、向系统中其他对象提供自身实例这一点是至关重要的，因为我们设置了ConfigManager类的构造器是私有的，所以外界是无法通过new操作符去获得它的实例的。那么就必须提供一个静态公有方法，该方法创建自身的实例并返回。所以我们定义了一个全局访问点getInstance()方法，该方法返回该类的实例，并做了逻辑判断，如果不为null则直接返回，不需要再创建实例\n以上单例模式的实现方式还存在很多弊端，比如并发环境下的线程安全问题等所以，进一步引申出单例模式的另外两种实现——懒汉模式和饿汉模式\n懒汉模式在类加载的时候不创建自身实例，而是采用延迟加载的方法，只在调用相关方法时才被动创建自身实例。正如上面的代码实现那样，只有在调用getInstance()方法时才创建类的实例。\n但是上述代码存在线程安全问题，进一步改进如下（修改getInstance()方法，考虑同步）：\n/***  对外公开的方法，延迟加载* */public static synchronized ConfigManager getInstance()&#123;    if (configManager==null)        configManager=new ConfigManager();    return configManager;&#125;\n但是，这种处理方式效率不高对于线程安全问题，还有一种解决方案，饿汉模式\n饿汉模式饿汉模式在类加载的时候就已经完成了初始化操作，所以类加载较慢，但是获取对象的速度很快。由于饿汉模式在类初始化时就完成了实例化，所以它是不存在线程安全问题的。\npackage Demo; import java.io.IOException;import java.io.InputStream;import java.util.Properties; /** *  单例模式 *  负责读取数据库连接信息 * */public class ConfigManager &#123;    private static ConfigManager configManager=new ConfigManager();  //加载时即实例化    private static Properties properties;     /**     *  私有构造函数，执行在整个程序运行期间只需要进行一次的操作     * */    private ConfigManager()&#123;        properties=new Properties();        InputStream inputStream=ConfigManager.class.getClassLoader().getResourceAsStream(&quot;data.properties&quot;);        try &#123;            properties.load(inputStream);            inputStream.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;      /**     *  对外公开的方法，延迟加载     * */    public static ConfigManager getInstance()&#123;        return configManager;    &#125;      /**     *  返回读取到的值     * */    public static String getValue(String key)&#123;        return properties.getProperty(key);    &#125;&#125;\n两种方式对比\n懒汉模式，在类加载时不创建实例，因此类加载速度快，但是运行时获取对象的速度较慢，具备延迟加载的特性，但是又存在线程不安全的问题。\n饿汉模式在类加载时就完成初始化，所以类加载较慢，但是获取对象的速度很快。\n懒汉模式是“时间换空间”，饿汉模式是“空间换时间”，因为一开始就创建了实例，所以每次使用时直接返回该实例就好了。\n\n分析了两种方式的优缺点后可进一步改进实现方式，综合两种方式的优点让饿汉模式同时具备延迟加载的特性，可以搭配静态内部类进行改造实现\n饿汉模式+静态内部类package Demo; import java.io.IOException;import java.io.InputStream;import java.util.Properties; /** *  单例模式 *  负责读取数据库连接信息 * */public class ConfigManager &#123;    private static ConfigManager configManager;    private static Properties properties;     /**     *  私有构造函数，执行在整个程序运行期间只需要进行一次的操作     * */    private ConfigManager()&#123;        properties=new Properties();        InputStream inputStream=ConfigManager.class.getClassLoader().getResourceAsStream(&quot;data.properties&quot;);        try &#123;            properties.load(inputStream);            inputStream.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;     /**     *  静态内部类     * */    public static class ConfigManagerHelp&#123;        private static final ConfigManager INSTANCE=new ConfigManager();  //静态常量    &#125;     /**     *  对外公开的方法，装载静态内部类，延迟加载     * */    public static ConfigManager getInstance()&#123;        configManager=ConfigManagerHelp.INSTANCE;        return configManager;    &#125;     /**     *  返回读取到的值     * */    public static String getValue(String key)&#123;        return properties.getProperty(key);    &#125;&#125;\n实现思路很简单，用静态内部类封装实例化，在调用getInstance()方法时加载实例化，且由于实例化采用静态常量，内存地址不变，所以在getInstance()方法只需要进行引用即可\n\n参考原文：https://blog.csdn.net/wzy18210825916/article/details/82835637 \n","categories":["设计模式"],"tags":["Java","设计模式"]},{"title":"可见性与原子性","url":"/2021/03/04/%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%80%A7/","content":"本篇介绍Java多线程中的可见性和原子性\n\n可见性如果在某一处对变量进行了写操作，则在另一处进行读操作时，能立即读到写后的最新值，这就叫可见性\n显然，在单线程的环境下，可见性是一定具备的\n但是在多线程的环境下，就不是这样了\n举个例子理解一下：\npublic class Visibility &#123;    static boolean flag = true;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            while (flag) &#123;            &#125;        &#125;).start();        Thread.sleep(1000);        flag = false;        System.out.println(flag);    &#125;&#125;\n输出结果：\n\n程序一直在运行并未停止，说明尽管在后面将flag的值改为了false，但线程中读取到的flag值一直为true\n这说明，若是普通的做法，并不能在多线程环境下保持可见性\n稍微修改一下上述代码：\npublic class Visibility &#123;    static boolean flag = true;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            while (flag) &#123;                try &#123;                    Thread.sleep(1);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;).start();        Thread.sleep(1000);        flag = false;        System.out.println(flag);    &#125;&#125;\n输出结果：\n\n在死循环中，让线程睡眠1ms，结果却是运行后立马程序就结束了\n这说明，在死循环中睡眠的那1ms中，线程读取到了更新后的变量最新值，即flag为false了，循环终止\n\n上述例子说明了多线程下可能存在的不可见问题，即一个线程写变量，另一个线程读变量时，可能无法立即读取到更新后的变量值\nvolatile关键字，保证了多线程下的可见性，即在主存和local cache之间保持了强制的一致性\n至于volatile关键字的底层原理相关内容，此处暂且不讨论…\n原子性一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性的含义\n举个例子，i++实际上分为三步：\n\n读取i\ni + 1\n赋值给i\n\n如果有两个线程，分别执行i++操作\npublic class AtomicDemo &#123;    static int i = 0;    public static void main(String[] args) throws InterruptedException &#123;        for (int k = 0; k &lt; 100000; k++) &#123;            new Thread(() -&gt; &#123;                i++;            &#125;).start();            new Thread(() -&gt; &#123;                i++;            &#125;).start();        &#125;        Thread.sleep(1000);        System.out.println(i);    &#125;&#125;\n输出：199996\n应该想要的预期结果是200000，可是上述做法却输出199996。使用volatile关键字修饰变量i，结果仍没有改变\n因为volatile关键字只保证了读阶段主存与local cache的数据一致性，而i++是分为三步进行的，读取i的阶段已保证了一致性，到了i+1写阶段并不会继续读取主存\n区别于可见性中的例子，一个线程执行读，另一个线程执行写。这个例子中两个线程都是既读又写\n此时可使用Java中提供的AtomicXXX类来保证原子性\npublic class AtomicDemo &#123;    static AtomicInteger i = new AtomicInteger(0);    public static void main(String[] args) throws InterruptedException &#123;        for (int k = 0; k &lt; 100000; k++) &#123;            new Thread(() -&gt; &#123;                i.getAndAdd(1);            &#125;).start();            new Thread(() -&gt; &#123;                i.getAndAdd(1);            &#125;).start();        &#125;        Thread.sleep(1000);        System.out.println(i);    &#125;&#125;\n输出：200000\n注意：\n保证原子性的前提，必须保证可见性\n但AtomicXXX类无需再用volatile修饰，因为其底层实现中，实际存储值的变量已使用volatile修饰\nprivate volatile int value;\n补充：\n\nvolatile不具有传染性，即用volatile修饰的对象的内部属性不具有可见性；反之，用volatile修饰的内部属性也不能保证所在对象的可见性\n\n也可使用synchronized关键字保证原子性，其保证了同一时间只有一个线程进入该代码块，但synchronized关键字是一种比较重量级的方式\nvolatile -&gt; AtomicXXX -&gt; synchronized：轻量 -&gt; 较轻量 -&gt; 重量，但相应的，其功能性也更丰富\n\n拓展：volatile还可防止指令重排，相关内容此处暂不讨论…\n\n\nReferenceshttps://www.bilibili.com/video/BV1wJ411a7jp\n","categories":["Java"],"tags":["Java","多线程"]},{"title":"多线程基础","url":"/2021/02/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","content":"本篇对进程、线程、并行、并发、死锁等基础概念进行了介绍\n\n进程与线程引入背景进程这个概念的诞生，与操作系统的发展息息相关\n最早期，计算机还没有操作系统的概念，处于手工操作阶段。用户每手动输入一个指令，计算机就做出相应的操作。这时期的计算机效率十分低下，其中突出的两个问题是：\n\n用户独占全机，不会出现因资源已被其他用户占用而等待的现象，但资源利用率低\nCPU等待手工操作，CPU的利用不充分\n\n为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，出现了批处理系统。单道批处理系统对作业的处理是成批进行的，但内存中始终保持一道作业，排在后面的作业必须等前面的作业完成之后才能执行，而当前面的作业由于I/O操作等原因发生堵塞时，CPU只能处于等待状态，所以效率也不高。之后引入了多道批处理系统，允许多个程序同时进入内存并允许它们在CPU中交替运行。实际上是，宏观上并行，微观上串行。\n\n这里有个疑问，多道批时期存在进程的概念了吗？\n我觉得严格意义上应该不算，因为多道批处理系统有一个缺陷就是不提供人机交互能力，即用户无法了解自己的程序的运行情况，这说明多道批中的数据并没有严格的关联，只是让它进到内存中去交替执行，然而通过进程，我们是可以了解该进程的执行状态的，一个进程中的数据也是有关联的\n\n计算机的发展离不开效率两个字，为了让计算机能够“同时”处理多个程序，使操作系统的并发性成为可能，于是提出了进程的概念\n引入进程的目的：为了更好地描述和控制程序并发执行，实现操作系统的并发性和共享性\n实际上，一个进程并不只有一个任务，对于一个进程中的多个子任务的执行，同样也存在着并发的概念。为了管理一个进程中的多个子任务，于是引入了线程的概念\n引入线程的目的：为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能\n基本概念进程（Process）：\n一段程序的执行过程，是动态的，包括从创建、运行到消亡的整个过程。是系统进行资源分配和调度的一个独立单位\n线程（Thread）：\n比进程更小的执行单位，也被称为“轻量级进程”，是程序执行的最小单位\n进程与线程的区别\n进程独占一定的内存空间，各进程之间互不干扰，数据共享复杂但同步简单；而线程依赖于进程存在，线程共享所属进程的内存空间及资源，各线程之间可能存在联系（同属一个进程），数据共享简单但同步复杂\n进程是独立的单位，一个进程出现问题，不会影响到其他进程，因此也不会影响到主程序的稳定性；而一个线程出现问题，可能会影响到其他线程，从而影响到整个程序的稳定性\n进程开销大；线程开销小\n进程是资源分配的基本单位；而线程是调度执行的基本单位\n\n多线程vs多进程为什么选择多线程方式而不是多进程方式呢？\n因为同一个进程的多个线程之间共享进程的堆区和方法区资源，但程序计数器、虚拟机栈和本地方法栈都是线程私有的，因此线程间通信相比于进程间通信更加简单，且线程相比于进程更加轻量，线程间切换和调度的成本要远小于进程，所以多线程方式的系统开销要远小于多进程方式\n多线程的风险多线程其实是一把双刃剑，实现并发性提升效率的同时，也带来了很多风险\n\n线程不安全。要编写一个线程安全的程序，有时候很难\n调试困难。由于线程执行顺序的不可预知和随机性，多线程的程序难以调试，难以重现\n死锁。线程间对共享资源的抢夺，会造成死锁\n内存泄漏。创建大量线程，若没有及时正确的释放资源，很可能会导致内存泄漏\n\n线程的生命周期\n\n\n\n状态名称\n说明\n\n\n\n\nNew\n初始化状态\n\n\nRunnable\n运行状态\n\n\nBlocked\n阻塞状态\n\n\nWaiting\n等待状态，等待其他线程做出一些特定动作（通知或中断）\n\n\nTimed_Waiting\n超时等待状态，不同于Waiting，该状态下可在指定的时间自行返回\n\n\nTerminated\n终止状态\n\n\n\n\n\n上下文切换上下文：\n指某一时间点 CPU 寄存器和程序计数器的内容\n上下文切换：\n就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器中的内容）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务\n而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行\n并行与并发并发（Concurrent）：指的是程序的结构，指能够让多个任务在逻辑上交织执行的程序设计\n并行（Parallel）：指的是程序运行时的状态，指物理上同时执行\n判断程序是否处于并行的状态，就看同一时刻是否有超过一个工作单位在运行。故，单线程永远无法达到并行状态\n并发设计的标准：使多个操作可以在重叠的时间段内进行\n操作系统的并发性是通过分时得以实现的\n\n\n死锁基本概念介绍死锁之前需对计算机系统中的各类资源有一个大体的了解\n可重用性资源一种可供用户重复使用多次的资源，它具有以下特性：\n\n每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享\n使用顺序：请求资源、使用资源、释放资源\n系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它\n\n计算机系统中大多数资源都属于可重用性资源\n可消耗性资源又称临时性资源，是在进程运行期间由进程动态的创建和消耗的\n它具有以下特性：\n\n每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的\n进程在运行过程中，可以不断地创造可消耗性资源的单元\n进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己消耗，不再将它们返回该资源类中\n\n可消耗性资源通常是由生产者进程创建，由消费者进程消耗\n最典型的可消耗性资源就是用于进程间通信的消息\n可抢占性资源某进程在获得这类资源后，该资源可被其他进程或系统抢占\nCPU和主存都属于可抢占性资源\n这类资源是不会引起死锁的\n不可抢占性资源一旦系统把某资源分配给某进程后，就不能将它强行收回，只能在进程用完后自行释放\n磁带机、打印机等都属于不可抢占性资源\n死锁当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁（Deadlock）\n产生死锁的必要条件\n互斥条件：进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放\n请求和保持条件：进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放\n不可抢占条件：进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放\n循环等待条件：一系列进程互相持有其他进程所需要的资源\n\n死锁只有在四个条件同时满足时发生，预防死锁则必须至少破坏其中一项\n死锁的处理策略死锁预防设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个，以防止发生死锁\n\n破坏互斥条件：\n不可行，有些资源不能同时访问（临界资源只能互斥使用）\n\n破坏请求和保持条件：\n预先静态分配，即在运行前一次性申请完所有需要的资源，运行时这些资源一直归它所有\n缺点：导致资源浪费，“饥饿”现象\n\n破坏不可抢占条件：\n当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，必须释放已经保持的所有资源\n缺点：实现复杂，频繁的申请和释放资源会增加系统开销，降低系统吞吐量\n\n破坏循环等待条件：\n采用顺序资源分配法，按编号顺序申请资源\n缺点：要求编号必须相对稳定，这限制了新类型设备的增加\n\n\n避免死锁在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁\n银行家算法（之后再具体介绍…）\n死锁的检测及解除无须采取任何限制性措施，允许进程在运行过程中发生死锁，通过系统的检测机构及时的检测出死锁的发生，然后采取某种措施解除死锁\n检测：\n资源分配图\n死锁定理：S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的\n解除：\n资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程\n撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源\n进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺\nReferencesJavaGuide\nhttp://concurrent.redspider.group/article/01/1.html\nhttp://geyifan.cn/2016/10/21/multiple-thread-problem/\nhttps://zhuanlan.zhihu.com/p/52845869\nhttps://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/\n","categories":["多线程"],"tags":["多线程"]},{"title":"学习Git前的小科普","url":"/2021/02/21/%E5%AD%A6%E4%B9%A0Git%E5%89%8D%E7%9A%84%E5%B0%8F%E7%A7%91%E6%99%AE/","content":"学习Git之前，有必要了解一下版本控制系统的发展历程（Linus NB\n\n关于版本控制版本控制系统（Version control，简称VCS），是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统\n本地版本控制\nRCS修订控制系统（Revision Control System，简称RCS)，是一款早期的版本控制系统\nRCS的工作原理是在硬盘上保存补丁集，通过应用所有的补丁，可以重新计算出各个版本的文件内容\n\n补丁：指文件修订前后的变化\n\n集中化的版本控制系统\n为了让不同系统上的开发者协同工作，于是诞生了集中化的版本控制系统（Centralized Version Control Systems，简称CVCS），比较典型的有CVS和SVN（Linus特别抵触集中式的版本控制系统，速度慢而且需要联网才能使用，这也是为什么Linus宁愿自己手动管理庞大的Linux内核代码，也不使用CVS和SVN的原因。当然，这也促使他后来写了个Git…）\n这类系统的工作原理是，有一个集中管理的服务器，保存着所有文件的修订版本，协同工作的开发者们都通过客户端连接到这台服务器，取出最新的文件或者提交更新\n缺陷：\n\n必须联网才能使用，网速慢体验就贼差\n\n极度依赖于中央服务器。如果中央服务器宕机，那么宕机的时间内谁都无法提交更新。更坏的情况，如果中央服务器磁盘损坏，且没做好数据备份，那数据直接就丢失了\n\n\n分布式版本控制系统\n为了克服集中式版本控制系统的弊端，分布式版本控制系统中的客户端并不只是提取最新版本的文件快照，而是把整个代码仓库完整的镜像下来，包括完整的历史记录（即完整备份）。这样，任何一处服务器发生故障，都可以利用任何一个镜像出来的本地仓库来恢复数据\n快照和镜像快照是一种基于时间点的数据拷贝技术，主要是记录某一特定时刻的数据信息并加以保存。快照技术分为物理拷贝和逻辑拷贝\n云镜像即在云端创建的服务器数据副本，主要用于创建容错和冗余服务器计算基础架构\n其中，物理拷贝快照和镜像的工作方式一样，都是将某个目标数据源的内容完整拷贝到其他地方，但不同之处在于：\n\n快照仅针对某个特定时刻的数据进行拷贝，无法记录在此之后的数据变化，快照的目标是将系统数据恢复至错误发生以前的某个时间\n\n镜像则需时刻保证目标数据和拷贝数据的一致，目的是保证数据冗余，在数据源发生故障时能够迅速恢复\n\n\n当用户目标数据源损坏，快照回滚将丢失最新修改的数据，而镜像则可以将其完整复原，以保证业务的连续\nGit诞生的背景随着Linux开源项目的兴起，众多参与者们编写的代码需要很好的进行管理。2002年之前，这项工作全部都由Linus本人手工完成。到了2002年，由于代码库过于庞大导致人为地进行管理变得困难，于是选择了BitKeeper这个分布式的版本控制系统。到了2005年，开发BitKeeper的商业公司收回了Linux内核社区免费使用BitKeeper的权力，原因是有社区成员试图破解BitKeeper的协议（BitMover公司也挺难受的，本着人道主义精神给你免费用付费商用产品，结果搞这么一出╮(╯-╰)╭）。然后，Linus花了两周时间自己写了个Git出来…（所以之前只是单纯的懒得写么（；´д｀）ゞ）\nReferenceshttps://git-scm.com/book/zh/v2\nhttps://zhuanlan.zhihu.com/p/263468970\nhttps://www.liaoxuefeng.com/wiki/896043488029600\n","categories":["Git"],"tags":["Git"]},{"title":"特殊字符转义表","url":"/2019/05/13/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B9%89%E8%A1%A8/","content":"记录一些特殊字符的转义字符，方便markdown文档的编写\n\n空格          &amp;nbsp;         &amp;#160;&#39;            &amp;apos;         &#39;&quot;            &quot;         &amp;#34;(            —              &amp;#40;)            —              &amp;#41;&lt;            &lt;           &amp;#60;&gt;            &gt;           &amp;#62;[            —              &amp;#91;]            —              &amp;#93;&#123;            —              &amp;#123;&#125;            —              &amp;#125;´            &amp;acute;        &amp;#180;°            &amp;deg;          &amp;#176;®            &amp;reg;          &amp;#174;©            &amp;copy;         &amp;#169;≤            &amp;le;           &amp;#8804;≥            &amp;ge;           &amp;#8805;≈            &amp;asymp;        &amp;#8773;≠            &amp;ne;           &amp;#8800;∩            &amp;cap;          &amp;#8745;∪           &amp;cup;          &amp;#8746;∠            &amp;ang;         &amp;#8736;∞            &amp;infin;        &amp;#8734;±            &amp;plusmn;       &amp;#177;√            &amp;radic;        &amp;#8730;∑            &amp;sum;          &amp;#8722;∫            &amp;int;          &amp;#8747;Δ            &amp;Delta;        &amp;#916;Φ            &amp;Phi;          &amp;#934;Ω            &amp;Omega;        &amp;#937;α            &amp;alpha;        &amp;#945;β            &amp;beta;         &amp;#946;γ            &amp;gamma;        &amp;#947;δ            &amp;delta;        &amp;#948;ε            &amp;epsilon;      &amp;#949;ζ            &amp;zeta;         &amp;#950;η            &amp;eta;          &amp;#951;θ            &amp;theta;        &amp;#952;λ            &amp;lambda;       &amp;#955;μ            &amp;mu;           &amp;#956;ξ            &amp;xi;           &amp;#958;π            &amp;pi;           &amp;#960;ρ            &amp;rho;          &amp;#961;σ            &amp;sigma;        &amp;#963;φ            &amp;phi;          &amp;#966;ψ            &amp;psi;          &amp;#968;ω            &amp;omega;        &amp;#969;∂            &amp;part;         &amp;#8706;∅            &amp;empty;        &amp;#8709;\n","categories":["工具"],"tags":["字符"]},{"title":"线程池技术","url":"/2021/02/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF/","content":"本篇介绍了线程池技术，包括线程池的实现原理，以及JDK提供的线程池中常见参数的含义\n\n线程池是什么线程池（thread pool），是一种线程的使用模式，基于池化的思想管理线程的工具\n\nPooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.\n\n池化，顾名思义，即资源分组、统一管理，以实现最大化收益并最小化风险\n为什么要用线程池线程过多会带来额外的开销，包括创建、销毁线程以及线程调度的各种开销，同时也降低了计算机的整体性能。而线程池解决的核心问题，就是线程资源的管理问题。在并发的环境下，系统不能确定在某一特定时刻有多少任务需要执行，有多少资源需要投入，这种不确定性会导致以下问题：\n\n频繁的创建、销毁和调度线程，带来巨大的额外开销\n对资源的无限制申请，导致资源消耗过多，从而造成服务器崩溃\n资源的管理不统一，降低系统的稳定性\n\n通过使用线程池技术，就能有效的解决上述问题：\n\n线程池可以复用已经创建的线程，减少了线程过多带来的额外开销问题\n线程池对并发的数量实现了有效的控制，避免因资源消耗过多而导致服务器崩溃（最主要原因）\n对线程资源进行统一管理，增强了系统稳定性\n\n线程池的实现原理在Java中，线程池的核心实现类是ThreadPoolExecutor，该实现类的顶层接口是Executor接口\n\nThreadPoolExecutor的构造方法及其参数含义// 五个参数的构造函数public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue)// 六个参数的构造函数-1public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory)// 六个参数的构造函数-2public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          RejectedExecutionHandler handler)// 七个参数的构造函数public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler)\n上述构造方法涉及的参数及其含义：\nint corePoolSize：线程池中核心线程数的最大值\n\n线程池中有两类线程，核心线程和非核心线程\n线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，若超过corePoolSize，则新建的是非核心线程\n核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（闲置状态）。当然，这只是默认情况，如果ThreadPoolExecutor的allowCoreThreadTimeOut属性为true，则核心线程闲置时长超过一定阈值（由参数设定）之后就会被销毁\n而非核心线程如果长时间的闲置，就会被销毁\n\nint maximumPoolSize：线程池中线程总数的最大值\n\n线程总数 = 核心线程数 + 非核心线程数\n\nlong keepAliveTime：非核心线程闲置超时时长\n\n一个非核心线程，如果闲置的时长超过这个参数所设定的时长，就会被销毁掉\n如果设置allowCoreThreadTimeOut = true，则会作用于核心线程\n\nTimeUnit unit：keepAliveTime的单位\n\nTimeUnit是一个枚举类型\n\nNANOSECONDS ： 1微毫秒 = 1微秒 / 1000\nMICROSECONDS ： 1微秒 = 1毫秒 / 1000\nMILLISECONDS ： 1毫秒 = 1秒 /1000\nSECONDS ： 秒\nMINUTES ： 分\nHOURS ： 小时\nDAYS ： 天\n\n\nBlockingQueue\\ workQueue：阻塞队列，维护着等待执行的Runnable任务对象\n\n当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务\n常见的几个阻塞队列：\n\nLinkedBlockingQueue\n链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小\n\nArrayBlockingQueue\n数组阻塞队列，底层数据结构是数组，需要指定队列的大小\n\nSynchronousQueue\n同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然\n\nDelayQueue\n延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素\n\n\n\nThreadFactory threadFactory：创建线程的工厂\n\n用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂\n\nRejectedExecutionHandler handler：拒绝处理策略\n\n当线程池不能执行该任务时（线程数量大于最大线程数），就交由拒绝执行处理器来处理该任务\n四种拒绝处理的策略为 ：\n\nThreadPoolExecutor.AbortPolicy\n默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常\n\nThreadPoolExecutor.DiscardPolicy\n丢弃新来的任务，但是不抛出异常\n\nThreadPoolExecutor.DiscardOldestPolicy\n丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）\n\nThreadPoolExecutor.CallerRunsPolicy\n用调用线程本身来执行此次提交的任务\n\n\n\n线程池的生命周期线程池本身有一个管理线程池的调度线程，它能管理线程池中的各种任务和事务，包括：创建线程、销毁线程、任务队列管理、线程队列管理等\nThreadPoolExecutor类中定义了一个volatile int变量runState来表示线程池的状态 \nThreadPoolExecutor的运行状态有5种：\n\n\n\n\n运行状态\n说明\n\n\n\n\nRUNNING\n线程池创建后处于RUNNING状态，能接受新提交的任务，也能处理阻塞队列中的任务\n\n\nSHUTDOWN\n关闭状态，不再接受新提交的任务，但能继续处理阻塞队列中已保存的任务\n\n\nSTOP\n不接受新任务，也不处理阻塞队列中的任务，中断正在处理任务的线程\n\n\nTIDYING\n所有的任务都已终止，workerCount（有效线程数）为0\n\n\nTERMINATED\n在terminated()方法执行完后进入该状态\n\n\n\n\n\n线程池的任务处理流程线程池实现类ThreadPoolExecutor处理任务的核心方法是execute()方法\n下面通过分析execute()方法的源码，来具体分析下线程池的任务处理流程\npublic void execute(Runnable command) &#123;    //检测空指针异常    if (command == null)        throw new NullPointerException();    //ctl.get()获取线程池状态，返回的是int类型数据    int c = ctl.get();    //若当前有效线程数小于核心线程数，则调用addWorker()方法创建核心线程执行任务    if (workerCountOf(c) &lt; corePoolSize) &#123;        if (addWorker(command, true))            return;        c = ctl.get();    &#125;    //若有效线程数大于等于核心线程数，线程池在运行状态，且通过offer()方法判断能将此任务添加到阻塞队列    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        //再次获取线程池的状态（因为状态可能会改变）        int recheck = ctl.get();        //若线程池不在运行状态，则remove这个任务，然后执行拒绝策略        if (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        //若线程池在运行状态，但是没有线程，则调用addWorker()方法创建线程执行任务        else if (workerCountOf(recheck) == 0)            addWorker(null, false);    &#125;    //如果放入workQueue失败，则创建非核心线程执行任务    //如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略    else if (!addWorker(command, false))        reject(command);&#125;\n注意到，上述处理流程中，recheck二次检查了线程池的状态，为什么要这样子做呢？\n因为在并发的环境下，线程池的状态是时刻发生变化的，判断是否将command添加到workqueue是线程池之前的状态，若不二次检查，线程池的状态改变了，处于非运行态，则command永远不会执行\n\n线程池如何实现线程复用前面讨论使用线程池的优势的时候，提到过线程池能够复用已存在的线程。设想一下，如果对于每个要执行的任务，都单独的创建一个相应的线程去执行，那么需要创建的线程数量是特别巨大的，这不仅增加了系统的开销，还有可能会过多的消耗系统资源从而导致服务器崩溃。\n事实上，我们也完全没必要为每一个任务单独的去创建一个线程去执行。线程池将线程和任务进行解耦，摆脱了之前通过Thread创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对Thread进行了封装，并不是每次执行任务都会调用Thread.start()来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停的检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的run方法，将run方法当成一个普通的方法执行，通过这种方式将只使用固定的线程就将所有任务的run方法串联起来。\n对于Java中线程复用的源码实现，这里不再展开分析，具体参见末尾引用博客中的内容\nJDK提供的四种线程池在大多数场景下，我们没有必要自己写一个线程池，JDK为我们提供了以下四种常用的线程池，这四种线程池都是直接或间接配置了ThreadPoolExecutor的参数而实现的\nnewCachedThreadPool源码：\npublic static ExecutorService newCachedThreadPool() &#123;    return new ThreadPoolExecutor(0,                                  Integer.MAX_VALUE,                                  60L,                                  TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());&#125;\n说明：\nExecutorService cachedThreadPool = Executors.newCachedThreadPool();\n可缓存线程池\ncorePoolSize为0，不创建核心线程\n线程数量不设限，线程池最大为Integer.MAX_VALUE\n任务添加到SynchronousQueue队列，如果入队成功，则等待空闲线程去执行。若没有空闲线程，则创建非核心线程，从队列中拉取任务去执行\n当需要执行很多短时间的任务时，CachedThreadPool的线程复用率比较高， 会显著的提高性能。而且线程60s后会回收，意味着即使没有任务进来，CachedThreadPool也不会占用很多资源\nnewFixedThreadPool源码：\npublic static ExecutorService newFixedThreadPool(int nThreads) &#123;        return new ThreadPoolExecutor(nThreads,                                      nThreads,                                      0L,                                      TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;());&#125;\n说明：\nExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);\n定长线程池\n可控制线程最大并发数（同时执行的线程数）\n核心线程数和线程总数相等，都为传入的参数nThreads。故只能创建核心线程，没有非核心线程\nLinkedBlockingQueue的默认大小为Integer.MAX_VALUE。故若有空闲核心线程，则交给其处理，若没有，则入队等待\nnewSingleThreadExecutor源码：\npublic static ExecutorService newSingleThreadExecutor() &#123;    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1,                                1,                                0L,                                TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;\n说明：\nExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();\n单线程化的线程池\n核心线程数和线程总数相等，都为1。故有且仅有一个核心线程来执行任务\n使用的是LinkedBlockingQueue队列，所有任务按先来先执行的顺序执行\nnewScheduledThreadPool源码：\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;    return new ScheduledThreadPoolExecutor(corePoolSize);&#125;//ScheduledThreadPoolExecutor():public ScheduledThreadPoolExecutor(int corePoolSize) &#123;    super(corePoolSize,          Integer.MAX_VALUE,          DEFAULT_KEEPALIVE_MILLIS,          MILLISECONDS,          new DelayedWorkQueue());&#125;\n说明：\nScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);\n定长线程池\n支持定时及周期性任务执行\n使用的是DelayedWorkQueue队列，延迟执行\nReferenceshttp://concurrent.redspider.group/article/03/12.html\nhttps://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html\nhttps://juejin.cn/post/6844904205623246861#heading-7\n","categories":["Java"],"tags":["Java","多线程"]},{"title":"HashMap详解","url":"/2021/02/08/HashMap%E8%AF%A6%E8%A7%A3/","content":"本篇从源码入手，详细分析了HashMap的底层实现逻辑\n\nHashMapHashMap是Java1.2引入的一种基于哈希表的Map接口的非同步实现\n特点底层实现：基于哈希表（数组+链表+红黑树）\n允许null值的key和value，key不允许重复（故只能有一个null值），value允许重复（故可有多个null值）\n无序，即不保证插入映射的顺序，特别的，不保证该顺序随时间保持不变\n线程不安全\n源码分析基本结构public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;        implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;    /**     * 默认初始容量16，必须为2的幂（关于这点的原因接下来再讨论）     */    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16    /**     * 最大的容量，1&lt;&lt;30 即 2^30     */    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    /**     * 默认的负载因子为 0.75     * 就是说，HashMap的默认初始容量是16，当HashMap中的元素个数超过16*0.75=12时，就会进行扩容     */    static final float DEFAULT_LOAD_FACTOR = 0.75f;    /**     * 树化的阈值，即当桶中链表的长度大于8时，链表将转化为红黑树（为什么是大于8就树化呢？~）     */    static final int TREEIFY_THRESHOLD = 8;    /**     * 由树转化为链表的阈值，即当链表的长度小于6时，继而调整为链表     */    static final int UNTREEIFY_THRESHOLD = 6;    /**     * 树化还对数组的长度有要求，即只有当链表长度&gt;8且数组的长度&gt;=64时才能转化为红黑树     * 如果当前数组的长度小于64，那么会先进行数组的扩容     */    static final int MIN_TREEIFY_CAPACITY = 64;    /**     * 保存元素的数组     * HashMap中存储的元素都是键值对（key-value）     */    transient Node&lt;K, V&gt;[] table;    /**     * 记录元素个数     */    transient int size;        /**     * Node节点的结构     * 可见Node节点类是HashMap的一个静态内部类     */    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;\t//由于存在链表结构，所以还需要记录当前节点的下一个节点        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        &#125;        //...    &#125;&#125;\n上面的部分源码让我们对HashMap的底层结构有了一个大致的了解，即HashMap是一种基于数组加链表的结构来存储键值对的集合容器，在JDK1.8之后还引入了红黑树这种结构，使得链表的长度大于一定的阈值之后，将链表转换为红黑树，从而进一步的提升效率\n构造方法/** * 指定初始容量和负载因子构造一个空的HashMap */public HashMap(int initialCapacity, float loadFactor) &#123;    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                loadFactor);    this.loadFactor = loadFactor;    /**     * threshold：阈值，HashMap中存储的键值对数量超过阈值则需进行扩容。阈值的计算方法为：容量大小*负载因子     */    this.threshold = tableSizeFor(initialCapacity);&#125;/** * 指定初始容量，使用默认负载因子（0.75）构造一个空的HashMap */public HashMap(int initialCapacity) &#123;    this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/** * 使用默认初始容量（16）和默认负载因子（0.75）构造一个空的HashMap */public HashMap() &#123;    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;/** * 带参构造 */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);&#125;\ntableSizeFor()方法源码中赋值threshold时调用的是tableSizeFor()方法，下面分析一下这个方法\nstatic final int tableSizeFor(int cap) &#123;    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;\n该方法的作用是找到大于或等于给定容量的最小2的次幂值，即保证了HashMap的容量为2的幂次方\n&gt;&gt;&gt;是无符号右移运算符，区别于&gt;&gt;的是，它右移时补0，而&gt;&gt;补符号位\n\n从上面的简单分析可见，右移一位，就将1后面的一位变成了1，1+2+4+8+16=31。java中的int占4字节，即32位，刚好可以得到最大值32个1。该方法使得最高位的1后面的所有位都变为1，最后再+1，使得最高位1的前一位变为1，后面所有位都为0，刚好得到2的整数次幂\n注意到，该方法的第一条语句就将cap值减去了1，这里减去1的目的是：当传入的数值恰好是2的次幂时，使得该方法能返回原数值，若不减1，则会返回原数值的2倍，造成空间的浪费\nput方法【重点】public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125;\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    //table未初始化时为null，size为0，此时对数组初始化，赋予数组默认初始容量即16    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    //table不为空，通过计算hash来找到数组下标，若该位置还没数据，则直接插入    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    //若该位置已有数据，即发生hash冲突，下面代码处理hash冲突    else &#123;        Node&lt;K,V&gt; e; K k;        //如果插入数据的key等于该位置处的key，则将e指向该键值对        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        //如果该位置的桶中元素的数据类型为TreeNode，则进行红黑树的元素插入        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        //否则，若桶中元素还是链表结构        else &#123;            //循环迭代            for (int binCount = 0; ; ++binCount) &#123;                //若链表中没有要插入的新节点元素，就将该新元素插入到链表尾部                if ((e = p.next) == null) &#123;                    p.next = newNode(hash, key, value, null);                    //树化的阈值判断                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                &#125;                //若链表中有要插入的新节点元素，则将e赋值给该节点                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            &#125;        &#125;        //e不为空，表示存在该key的映射，就更新该位置的键值对        /* 举个例子，比如原来的HashMap中有一个键值对&#123;&quot;小明&quot;,&quot;上海&quot;&#125;，此时插入一个新的键值对&#123;&quot;小明&quot;,&quot;北京&quot;&#125;，通过上面的处理，          * 发现原HashMap中存在key=&quot;小明&quot;的键值对，这时就会将新插入的键值对覆盖掉原来key=&quot;小明&quot;处的键值对，即再查找HashMap中          * key=&quot;小明&quot;的键值对时，它对应的value就是&quot;北京&quot;了         */        if (e != null) &#123; // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        &#125;    &#125;    ++modCount;    //阈值检测，超过则进行扩容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;&#125;\nput方法流程总结\n首先调用hash()方法计算key的hash值\n如果table数组为空，则调用resize()方法实现数组初始化，赋予数组默认初始容量16\n如果table不为空，则根据hash值找到键值对应该存储到的数组下标\n若该位置还没有元素，即hash不冲突，则直接插入\n若该位置已有数据，即产生hash冲突，则处理冲突，处理冲突的流程是：\n判断原有数据的key值与新插入数据的key值是否相等\n若key相等，则先记录原有数据（给e赋值为原有数据）\n若key不等，则再判断原有数据的数据类型是否是TreeNode\n若原有数据为TreeNode类型，则按红黑树的插入方式插入新元素\n若原有数据不为TreeNode类型，即桶中还是链表结构，则遍历该桶中的链表，判断是否能找到相同key值的数据\n若未找到相同key值的数据，则将新插入数据添加到链表末尾，添加时还需注意链表树化的阈值判断\n若找到相同key值的数据，则记录下该数据\n最后若e不为空，则表示原集合中存在该key的映射，需要用新数据覆盖原数据\n\n\n上述操作完成后，更新修改次数参数，还需进行阈值检测，超出阈值则进行扩容操作\n\n扩容方法resize()【重点】上面对put方法的源码分析过程中，发现table未初始化时进行扩容和阈值检测进行扩容时都调用了resize()方法，下面重点分析下这个方法\n/** * Initializes or doubles table size.  If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table *///从上述官方源码的注释上可见，resize()这个方法是实现初始化数组或数组扩容final Node&lt;K,V&gt;[] resize() &#123;    //下面是初始化一些参数    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    //若旧容量大于0，这也表明table已经初始化了    if (oldCap &gt; 0) &#123;        //最大值（上限）检测        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            return oldTab;        &#125;        //若旧容量不小于默认初始容量16且两倍扩容后的容量值小于上限值，则进行两倍扩容且相应的阈值也扩到两倍        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    &#125;    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    //oldCap==0且oldThr==0，则使用默认的初始化值    else &#123;               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    //新阈值计算    if (newThr == 0) &#123;        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    &#125;    //更新阈值    threshold = newThr;        //经过上面的操作，已经确定好了（是否）扩容后的新容量和新阈值，接下来就要更新数组了    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) &#123;        for (int j = 0; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) &#123;                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else &#123; // preserve order                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do &#123;                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) &#123;                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        &#125;                        else &#123;                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; while ((e = next) != null);                    if (loTail != null) &#123;                        loTail.next = null;                        newTab[j] = loHead;                    &#125;                    if (hiTail != null) &#123;                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    return newTab;&#125;\n扩容流程总结\n判断数组是否初始化，若尚未初始化，则初始化赋值默认容量和默认阈值\n若数组已经初始化，则扩容为旧容量的两倍，同时需要注意上限的检测还有更新阈值\n进行扩容后数组的更新，即重新计算hash（这部分的具体逻辑不是很懂＞﹏＜）\n若新计算的位置数据为空，则直接插入\n若新计算的位置是链表结构，则重新计算下标，对链表分组\n若新计算的位置是红黑树结构，则进行拆分操作\n\n\n\nget()方法public V get(Object key) &#123;    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;\nfinal Node&lt;K,V&gt; getNode(int hash, Object key) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    //根据hash值获取指定下标处元素    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) &#123;        //若该下标位置的元素的key值正好等于要查找的key值，则返回该元素        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        //若不是，则要从桶中所有元素中找        if ((e = first.next) != null) &#123;            //如果是红黑树结构，则调用红黑树的查找方法            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            //若是链表结构，则遍历链表来查找            do &#123;                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            &#125; while ((e = e.next) != null);        &#125;    &#125;    //找不到，返回null    return null;&#125;\nremove()方法public V remove(Object key) &#123;    Node&lt;K,V&gt; e;    return (e = removeNode(hash(key), key, null, false, true)) == null ?        null : e.value;&#125;\nfinal Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                           boolean matchValue, boolean movable) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;    //要删除一个指定数据，首先得找到它，下面查找的代码与get()源码一致    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;        Node&lt;K,V&gt; node = null, e; K k; V v;        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            node = p;        else if ((e = p.next) != null) &#123;            if (p instanceof TreeNode)                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);            else &#123;                do &#123;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key ||                         (key != null &amp;&amp; key.equals(k)))) &#123;                        node = e;                        break;                    &#125;                    p = e;                &#125; while ((e = e.next) != null);            &#125;        &#125;        //若找到了要删除的数据，则进行删除操作        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                             (value != null &amp;&amp; value.equals(v)))) &#123;            //如果是红黑树结构，则按红黑树的删除方法去删除            if (node instanceof TreeNode)                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);            //如果是要删第一个节点，则直接指向下一个节点即可            else if (node == p)                tab[index] = node.next;            //否则，通过链表的方式删除            else                p.next = node.next;            ++modCount;            --size;            afterNodeRemoval(node);            return node;        &#125;    &#125;    return null;&#125;\nhash()扰动函数【重点】static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;\n分析key的hashCode值默认是根据key的内存地址得到的一个int型散列值，而32位带符号的int值范围是-2147483648到2147483648，一共是40多亿的映射空间，内存是放不下这么大空间的\n从源码中可以看到tab[(n - 1) &amp; hash]，是用hash值对数组的长度取模，将得到的余数作为下标去访问。注意，这里说是取模，但是却用的是&amp;运算，这是因为&amp;的效率要远高于%。而且，只有在容量为2的次幂时，( n - 1 ) &amp; hash才等效于hash % n，这也解释了为什么HashMap的容量必须是2的幂，以及为什么是两倍扩容\n&amp;操作的结果是散列值的高位全部归零，只保留低位值。(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，按位异或它自身右移16位后的数值，这样做的目的是：混和原hash值的高位和地位，加大低位的随机性（而且混合后的低位也掺杂了高位的部分特征，相当于变相保留了高位的信息），让hash值分布更均匀，从而降低hash冲突发生的概率，提高HashMap存取的效率\n问题补充负载因子为什么是0.75？\n* &lt;p&gt;As a general rule, the default load factor (.75) offers a good* tradeoff between time and space costs.  Higher values decrease the* space overhead but increase the lookup cost (reflected in most of* the operations of the &lt;tt&gt;HashMap&lt;&#x2F;tt&gt; class, including* &lt;tt&gt;get&lt;&#x2F;tt&gt; and &lt;tt&gt;put&lt;&#x2F;tt&gt;).  The expected number of entries in* the map and its load factor should be taken into account when* setting its initial capacity, so as to minimize the number of* rehash operations.  If the initial capacity is greater than the* maximum number of entries divided by the load factor, no rehash* operations will ever occur.\n\n简单来说，默认负载因子设置为0.75在时间和空间成本之间提供了一个很好的权衡\n当负载因子过大时，虽然空间的利用率是提高了，但这也意味着桶上的链表或者红黑树存储的元素更多了，红黑树的结构更复杂，使得查找的效率降低了\n当负载因子过小时，虽然桶上的链表长度或者红黑树的高度会降低，这有利于数据的查询效率，但是很显然内存空间的利用率降低了\n容量为什么是2的幂次方？以及为什么是两倍扩容？上面提到，只有在容量为2的幂次方时，( n - 1 ) &amp; hash才等效于hash % n，在HashMap中通过取模获得数组下标的操作是很频繁的，而&amp;操作的效率远高于%，所以保证容量是2的幂次方能有效地提升HashMap的存取效率，而两倍扩容也正好维持了容量是2的幂次方\n而且，容量为2的幂次方时，n - 1的二进制全为1，位运算时就可充分散列，减少hash冲突，提升效率\nReferenceshttps://juejin.cn/post/6844903799748821000\nhttps://www.cnblogs.com/loading4/p/6239441.html\nhttps://www.zhihu.com/question/20733617\n","categories":["Java"],"tags":["集合框架"]},{"title":"JUnit单元测试","url":"/2021/01/02/JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","content":"本篇对JUnit单元测试相关的知识点进行了较详细的整理和总结，学习使用JUnit进行简单的单元测试吧\n\n什么是单元测试？单元测试负责对最小的软件设计单元（模块）进行验证，它使用软件设计文档中对模块的描述作为指南，对重要的程序分支进行测试以发现模块中的错误。\n这里的最小可测试单元通常是指函数或者类。\n什么是单元测试框架？对于单元测试框架来讲，它主要完成以下几件事。\n提供用例组织与执行： 当你的测试用例只有几条时，可以不必考虑用例的组织，但是，当测试用例达到成百上千条时，大量的测试用例堆砌在一起，就产生了扩展性与维护性等问题，需要考虑用例的规范与组织问题了。单元测试框架就是用来解决这个问题的。\n提供丰富的断言方法： 不论是功能测试，还是单元测试，在用例执行完成之后都需要将实际结果与进行预期结果的进行比较（断言），从而断定用例是否执行通过。单元测试框架一般会提供丰富的断言方法。例如，判断相等/不等、包含/不包含、True/False的断言方法等。\n提供丰富的日志： 当测试用例执行失败时能抛出清晰的失败原因，当所有用例执行完成后能提供丰富的执行结果。例如，总执行时间、失败用例数、成功用例数等。\n从这些特性来看单元测试框架的作用是：帮助我们更自动化测试完成测试，所以，它是自动化测试的基础。\nJUnitJUnit 是一个编写可重复测试的简单框架。它是单元测试框架的 xUnit 架构的一个实例。\nJUnit编写单元测试package com.junitdemo;import static org.junit.Assert.assertEquals;import org.junit.Test;public class JUnitDemo &#123;    //assertEquals() 方法用于断言两个值是否相关。    @Test    public void myFirstTest() &#123;        assertEquals(2 + 2, 4);    &#125;&#125;\n被测试类Count\npublic class Count &#123;    /**     * 计算并返回两个参数的和     */    public int add(int x ,int y)&#123;        return x + y;    &#125;&#125;\n 测试类CountTest\nimport static org.junit.Assert.assertEquals;import org.junit.Test;public class CountTest &#123;    @Test    public void testAdd() &#123;        Count count = new Count();        int result = count.add(2,2);        assertEquals(result, 4);    &#125;&#125;\nJUnit注解\n\n\n\n注解\n说明\n\n\n\n\n@Test\n标识一条测试用例\n\n\n@Ignore\n忽略的测试用例\n\n\n@Before\n每一个测试方法之前运行\n\n\n@After\n每一个测试方法之后运行\n\n\n@BeforeClass\n所有测试开始之前运行\n\n\n@AfterClass\n所有测试结果之后运行\n\n\n\n\nJUnit注解例子\n被测试类Count\npackage com.junitdemo;public class Count &#123;    /**     * 计算两数之和     */    public int add(int x, int y) &#123;        return x + y;    &#125;    /**     * 计算两数相除     */    public int division(int a, int b) &#123;        return a / b;    &#125;&#125;\n测试类CountTest\npackage com.junitdemo;import static org.junit.Assert.assertEquals;import org.junit.Ignore;import org.junit.Test;public class CountTest &#123;//    @Test//    public void testAdd() &#123;//        Count count = new Count();//        int result = count.add(2, 2);//        assertEquals(result, 4);//    &#125;    //验证超时    /*    在testAdd()用例中设置timeout=100,说明的用例的运行时间不能超过100毫秒，但故意在用例添加sleep()方法休眠101毫秒，所以会导致用例失败。     */    @Test(timeout = 100)    public void testAdd() throws InterruptedException &#123;        Thread.sleep(101);        new Count().add(1, 1);    &#125;    //验证抛出异常    /*    在Java中被除数不能为0，所以8/0会报ArithmeticException异常,在@Test中设置expected=ArithmeticException.class，说明抛该异常符合预期。     */    @Test(expected = ArithmeticException.class)    public void testDivision() &#123;        new Count().division(8, 0);    &#125;    //跳过该条用例    /*    @Ignore表来标识该用例跳过,不管用例运行成功还是失败。     */    @Ignore    @Test    public void testAdd2() &#123;        Count count = new Count();        int result = count.add(2, 2);        assertEquals(result, 5);    &#125;&#125;\nJUnit注解之FixtureTest Fixture 是指一个测试运行所需的固定环境，准确的定义：\n\nThe test fixture is everything we need to have in place to exercise the SUT\n\n在进行测试时，我们通常需要把环境设置成已知状态（如创建对象、获取资源等）来创建测试，每次测试开始时都处于一个固定的初始状态；测试结果后需要将测试状态还原，所以，测试执行所需要的固定环境称为 Test Fixture。\npackage com.junitdemo;import static org.junit.Assert.*;import org.junit.*;public class TestFixture &#123;    //在当前测试类开始时运行。    @BeforeClass    public static void beforeClass() &#123;        System.out.println(&quot;-------------------beforeClass&quot;);    &#125;    //在当前测试类结束时运行。    @AfterClass    public static void afterClass() &#123;        System.out.println(&quot;-------------------afterClass&quot;);    &#125;    //每个测试方法运行之前运行    @Before    public void before() &#123;        System.out.println(&quot;=====before&quot;);    &#125;    //每个测试方法运行之后运行    @After    public void after() &#123;        System.out.println(&quot;=====after&quot;);    &#125;    @Test    public void testAdd1() &#123;        int result = new Count().add(5, 3);        assertEquals(8, result);        System.out.println(&quot;test Run testadd1&quot;);    &#125;    @Test    public void testAdd2() &#123;        int result = new Count().add(15, 13);        assertEquals(28, result);        System.out.println(&quot;test Run testadd2&quot;);    &#125;&#125;\n程序执行结果：\n-------------------beforeClass&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;beforetest Run testadd1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;after&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;beforetest Run testadd2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;after-------------------afterClass\nJUnit用例执行顺序@FixMethodOrder\nJUnit 通过 @FixMethodOrder 注解来控制测试方法的执行顺序的。@FixMethodOrder 注解的参数是 org.junit.runners.MethodSorters 对象，在枚举类 org.junit.runners.MethodSorters 中定义了如下三种顺序类型：\n\nMethodSorters.JVM\n\n\nLeaves the test methods in the order returned by the JVM. Note that the order from the JVM may vary from run to run (按照JVM得到的方法顺序，也就是代码中定义的方法顺序)\n\n\nMethodSorters.DEFAULT(默认的顺序)\n\n\nSorts the test methods in a deterministic, but not predictable, order() (以确定但不可预期的顺序执行)\n\n\nMethodSorters.NAME_ASCENDING\n\n\nSorts the test methods by the method name, in lexicographic order, with Method.toString() used as a tiebreaker (按方法名字母顺序执行)\n\npackage com.junitdemo;import org.junit.FixMethodOrder;import org.junit.Test;import org.junit.runners.MethodSorters;import static org.junit.Assert.assertEquals;@FixMethodOrder(MethodSorters.NAME_ASCENDING)/*    JVM: 按照JVM得到的方法顺序，也就是代码中定义的方法顺序，在这个例子中执行顺序为TestCase1()-&gt;TestCase2()-&gt;TestAa()    DEFAULT: 默认的顺序，以确定但不可预期的顺序执行    NAME_ASCENDING: 按方法名字母顺序执行，在这个例子中执行顺序为TestAa()-&gt;TestCase1()-&gt;TestCase2() */public class TestRunSequence &#123;    @Test    public void TestCase1() &#123;        assertEquals(2 + 2, 4);    &#125;    @Test    public void TestCase2() &#123;        assertEquals(2 + 2, 4);    &#125;    @Test    public void TestAa() &#123;        assertEquals(&quot;hello&quot;, &quot;hi&quot;);    &#125;&#125;\nJUnit断言方法\n\n\n\n方法\n说明\n\n\n\n\nassertArrayEquals(expecteds, actuals)\n查看两个数组是否相等。\n\n\nassertEquals(expected, actual)\n查看两个对象是否相等。类似于字符串比较使用的equals()方法。\n\n\nassertNotEquals(first, second)\n查看两个对象是否不相等。\n\n\nassertNull(object)\n查看对象是否为空。\n\n\nassertNotNull(object)\n查看对象是否不为空。\n\n\nassertSame(expected, actual)\n查看两个对象的引用是否相等。类似于使用“==”比较两个对象。\n\n\nassertNotSame(unexpected, actual)\n查看两个对象的引用是否不相等。类似于使用“!=”比较两个对象。\n\n\nassertTrue(condition)\n查看运行结果是否为true。\n\n\nassertFalse(condition)\n查看运行结果是否为false。\n\n\nassertThat(actual, matcher)\n查看实际值是否满足指定的条件。\n\n\nfail()\n让测试失败。\n\n\n\n\n一个使用assertTrue的例子\npackage com.junitdemo;import org.junit.*;import static org.junit.Assert.*;public class AssertTest &#123;    /**     * 判断一个数是否为素数     */    public static Boolean Prime(int n) &#123;        for (int i = 2; i &lt;= Math.sqrt(n); i++) &#123;            if (n % i == 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;    @Test    public void testPrime() &#123;        int n = 7;        assertTrue(AssertTest.Prime(n));    &#125;&#125;\nJUnit测试批量运行一、IntelliJ IDEA中设置\nRun菜单 —&gt; Edit Configurations…选项\n在 Junit 目录下，选择任意一个用例文件。\n\nTest Kind : 选择用例的运行类型/级别。\npackages : 选择用例运行的目录，即你的测试用例目录。\n\n设置完成后，点击 “OK” 按钮。\n二、测试套件\nJUnit 提供了一种批量运行测试类的方法，叫测试套件。\n测试套件的写法需要遵循以下原则：\n\n创建一个空类作为测试套件的入口；\n使用注解 org.junit.runner.RunWith 和 org.junit.runners.Suite.SuitClasses 修饰这个空类。\n将 org.junit.runners.Suite 作为参数传入给注解 RunWith，以提示 JUnit 为此类测试使用套件运行器执行。\n将需要放入此测试套件的测试类组成数组作为注解 SuiteClasses 的参数。\n保证这个空类使用public修饰，而且存在公开的不带任何参数的构造函数。\n\npackage com.junitdemo;import org.junit.runner.RunWith;import org.junit.runners.Suite;import org.junit.runners.Suite.SuiteClasses;@RunWith(Suite.class)/** * 把需要运行的测试类放到 SuiteClasses 中，运行 runAllTest 测试类，即可批量执行测试用例。 */@SuiteClasses(&#123;        CountTest.class,        TestFixture.class,        AssertTest.class,        TestRunSequence.class,&#125;)public class RunAllTest &#123;&#125;\n以上大概就是JUnit4的主要内容了，接下来了解一下JUnit5的一些新功能\nJUnit5\nJUnit 5 is the next generation of JUnit. The goal is to create an up-to-date foundation for developer-side testing on the JVM. This includes focusing on Java 8 and above, as well as enabling many different styles of testing.\nWhat is JUnit5?\nUnlike previous versions of JUnit, JUnit 5 is composed of several different modules from three different sub-projects.\nJUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage\nThe JUnit Platform serves as a foundation for launching testing frameworks on the JVM. It also defines the TestEngine API for developing a testing framework that runs on the platform. Furthermore, the platform provides a Console Launcher to launch the platform from the command line and a JUnit 4 based Runner for running any TestEngine on the platform in a JUnit 4 based environment. First-class support for the JUnit Platform also exists in popular IDEs (see IntelliJ IDEA, Eclipse, NetBeans, and Visual Studio Code) and build tools (see Gradle, Maven, and Ant).\nJUnit Jupiter is the combination of the new programming model and extension model for writing tests and extensions in JUnit 5. The Jupiter sub-project provides a TestEngine for running Jupiter based tests on the platform.\nJUnit Vintage provides a TestEngine for running JUnit 3 and JUnit 4 based tests on the platform.\n\nJUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage\n\nJUnit Platform 是在JVM上启动测试框架的基础。\nJUnit Jupiter 是JUnit5扩展的新的编程模型和扩展模型，用来编写测试用例。Jupiter子项目为在平台上运行Jupiter的测试提供了一个TestEngine （测试引擎）。\nJUnit Vintage 提供了一个在平台上运行 JUnit3 和 JUnit4 的 TestEngine 。\n\n一个简单的JUnit5测试用例：\npackage com.junitdemo;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;public class JUnit5Demo &#123;    @Test    void myFirstTest() &#123;        assertEquals(2, 1 + 1);    &#125;&#125;\n首先，导入测试测试注解（@Test）和断言方法（assertEquals）的路径不同。\n其次，不需要手动把测试和测试方法声明为 public 了。\nJUnit5的新用法JUnit5常用注解\n\n\n\n注解\n说明\n\n\n\n\n@Test\n表明这是一个测试方法，类比于 JUnit 4 的@Test但是不支持任何参数\n\n\n@ParameterizedTest\n带参数的测试\n\n\n@RepeatedTest\n使测试重复执行\n\n\n@TestFactory\n该方法是一个支持动态测试的测试工厂\n\n\n@TestTemplate\n该方法是一个测试模板，支持在不同的测试场景下的多次调用\n\n\n@TestMethodOrder\n配置测试方法的执行顺序\n\n\n@TestInstance\n配置测试实例的生命周期\n\n\n@DisplayName\n自定义显示名称\n\n\n@DisplayNameGeneration\n自定义显示名称生成器\n\n\n@BeforeEach\n该方法会在当前类的每一个测试方法之前执行，包括：@Test, @RepeatedTest, @ParameterizedTest, @TestFactory, 与 JUnit 4 的@Before 类似\n\n\n@AfterEach\n该方法会在当前类的每一个测试方法之后执行，包括：@Test, @RepeatedTest, @ParameterizedTest, @TestFactory, 与 JUnit 4 的@After 类似\n\n\n@BeforeAll\n该方法在当前类的所有测试方法之前执行，类似于 JUnit 4 的@BeforeClass\n\n\n@AfterAll\n该方法在当前类的所有测试方法之后执行，类似于 JUnit 4 的@AfterClass\n\n\n@Tag\n用于测试的过滤，类似于 JUnit 4 的 Category 和 TestNG 的 Group\n\n\n@Disabled\n禁用当前测试，类比于 JUnit 4 的@Ignore\n\n\n@TempDir\n通过字段注入或参数注入提供一个临时目录\n\n\n\n\n@DisplayName用例package com.junitdemo;import org.junit.jupiter.api.*;@DisplayName(&quot;display name demo&quot;)public class DisplayNameDemo &#123;    @Test    @DisplayName(&quot;simple name test&quot;)    void testSimpleName() &#123;    &#125;    @Test    @DisplayName(&quot;╯°□°）╯&quot;)    void testSpecialCharacters() &#123;    &#125;    @Test    @DisplayName(&quot;😱&quot;)    void testWithDisplayNameContainingEmoji() &#123;    &#125;&#125;\n\n更强大的断言Assertionspackage com.junitdemo;import org.junit.jupiter.api.*;import static java.time.Duration.ofMillis;import static java.time.Duration.ofMinutes;import static org.junit.jupiter.api.Assertions.*;public class JUnit5Assertions &#123;    /**     * assertEquals和assertTrue的消息放在第三个参数，而不是第一个     */    @Test    void standardAssertions() &#123;        assertEquals(2, 1 + 1);        assertEquals(4, 2 * 2, &quot;The optional failure message is now the last parameter&quot;);        assertTrue(&#x27;a&#x27; &lt; &#x27;b&#x27;, () -&gt; &quot;Assertion messages can be lazily evaluated -- &quot;                + &quot;to avoid constructing complex messages unnecessarily.&quot;);    &#125;    /**     * assertAll表示分组断言，每一个分组都会执行，任何一个分组执行失败都会导致该测试失败。     */    @Test    void groupedAssertions() &#123;        // In a grouped assertion all assertions are executed, and all        // failures will be reported together.        assertAll(&quot;person&quot;,                () -&gt; assertEquals(&quot;Jane&quot;, &quot;Jane&quot;),                () -&gt; assertEquals(&quot;Doe&quot;, &quot;Doe&quot;)        );    &#125;    /**     * 但是同一个分组中（block）的断言之间有前后依赖关系，即如果前面的断言失败了，后面的断言不会执行。     */    @Test    void dependentAssertions() &#123;        // Within a code block, if an assertion fails the        // subsequent code in the same block will be skipped.        assertAll(&quot;properties&quot;,                () -&gt; &#123;                    String firstName = &quot;Jane&quot;;                    assertNotNull(firstName);                    // Executed only if the previous assertion is valid.                    assertAll(&quot;first name&quot;,                            () -&gt; assertTrue(firstName.startsWith(&quot;J&quot;)),                            () -&gt; assertTrue(firstName.endsWith(&quot;e&quot;))                    );                &#125;,                () -&gt; &#123;                    // Grouped assertion, so processed independently                    // of results of first name assertions.                    String lastName = &quot;Doe&quot;;                    assertNotNull(lastName);                    // Executed only if the previous assertion is valid.                    assertAll(&quot;last name&quot;,                            () -&gt; assertTrue(lastName.startsWith(&quot;D&quot;)),                            () -&gt; assertTrue(lastName.endsWith(&quot;e&quot;))                    );                &#125;        );    &#125;    /**     * assertThrows测试抛出的异常。     */    @Test    void exceptionTesting() &#123;        Exception exception = assertThrows(ArithmeticException.class, () -&gt; divide(1, 0));        assertEquals(&quot;/ by zero&quot;, exception.getMessage());    &#125;    private int divide(int a, int b) &#123;        return a / b;    &#125;    /**     * assertTimeout测试超时，assertTimeoutPreemptively表示抢占超时，即如果超时了，方法还没有返回，则立即中断执行。     * java.time.Duration.ofMinutes()方法：公共持续时间(分钟)方法获得表示多个标准分钟的持续时间。minutes - 分钟数，正或负数。     * java.time.Duration.ofMillis()方法：获取表示多个标准小时数的持续时间。millis - 毫秒数，正数或负数。     */    @Test    void timeoutNotExceeded() &#123;        // The following assertion succeeds.        assertTimeout(ofMinutes(2), () -&gt; &#123;            // Perform task that takes less than 2 minutes.        &#125;);    &#125;    @Test    void timeoutNotExceededWithResult() &#123;        // The following assertion succeeds, and returns the supplied object.        String actualResult = assertTimeout(ofMinutes(2), () -&gt; &quot;a result&quot;);        assertEquals(&quot;a result&quot;, actualResult);    &#125;    @Test    void timeoutExceeded() &#123;        // The following assertion fails with an error message similar to:        // execution exceeded timeout of 10 ms by 91 ms        assertTimeout(ofMillis(10), () -&gt; &#123;            // Simulate task that takes more than 10 ms.            Thread.sleep(100);        &#125;);    &#125;    @Test    void timeoutExceededWithPreemptiveTermination() &#123;        // The following assertion fails with an error message similar to:        // execution timed out after 10 ms        assertTimeoutPreemptively(ofMillis(10), () -&gt; &#123;            // Simulate task that takes more than 10 ms.            Thread.sleep(100);        &#125;);    &#125;&#125;\n\nReferencesJUnit官方文档\nhttp://www.testclass.net/junit\nhttps://nkcoder.github.io/2020/02/junit5-tutorial/\n","categories":["软件测试"],"tags":["JUnit"]},{"title":"JavaScript数据类型","url":"/2021/01/25/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"记录JavaScript中的各种数据类型，包括重要的基本概念和常用方法，还有一些容易迷惑的点\n\n数据类型\n数值（number）\n字符串（string）\n布尔值（boolean）\n未定义（undefined）\n空值（null）\n对象（object）\n狭义的对象（object）\n数组（array）\n函数（function）：函数当作数据类型可以赋值给变量，为JS的“函数式编程”奠定基础\n\n\nSymbol（ES6新增）\n\n确定数据类型的方式JavaScript 有三种方法，可以确定一个值到底是什么类型\n\ntypeof运算符\ninstanceof运算符\nObject.prototype.toString方法\n\ntypeof运算符console.log(typeof 123); //numberconsole.log(typeof &quot;Hello&quot;); //stringconsole.log(typeof true); //booleanconsole.log(typeof undefined); //undefinedconsole.log(typeof null); //objectvar person = &#123;    name: &quot;Alice&quot;,    age: 50&#125;;console.log(typeof person); //objectconsole.log(typeof []); //objectfunction f() &#123;&#125;console.log(typeof f); //function\nnull的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了\n函数隶属于 object 类型。但是 typeof 会对函数区分对待，并返回 &quot;function&quot;。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便\nnull和undefined\nnull：可以将其赋值给变量以表示无值（或者叫做值为null），转为数值为0\nundefined：表示已声明变量但尚未分配值，转为数值为NaN\nvar a = null;console.log(typeof a);  //objectvar b;console.log(typeof b);  //undefined\nnull === undefined // falsenull == undefined // true\n布尔值（boolean）布尔值的转换规则：以下为false，其他视为true\n\nundefined\nnull\nfalse\n0\nNaN\n&quot;&quot;或&#39;&#39;\n\n特别注意：空数组（[]）和空对象（&#123;&#125;）对应的布尔值都是true\n数值（number）整数和浮点数JavaScript底层所有的数字都是以64位浮点数形式存储的，故不存在整数的概念（在某些只有整数才能参与的运算中，JavaScript会自动把64位浮点数转换成32位整数）\n浮点数不精确\n0.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false\n数值精度IEEE 754浮点数相关问题暂搁置，后续详细学习后再总结这方面知识\n数值范围如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity\n如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0\nJavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值\nBigInt类型在 JavaScript 中，“number” 类型无法表示大于 (2^53-1)（即 9007199254740991），或小于 -(2^53-1) 的整数。这是其内部表示形式导致的技术限制\n在大多数情况下，这个范围就足够了，但有时我们需要很大的数字，例如用于加密或微秒精度的时间戳\nBigInt 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数\n可以通过将 n 附加到整数字段的末尾来创建 BigInt 值\n// 尾部的 &quot;n&quot; 表示这是一个 BigInt 类型const bigInt = 1234567890123456789012345678901234567890n;\n科学计数法以下两种情况，JavaScript会自动将数值转为科学计数法表示\n\n小数点前的数字多于21位\n小数点后的零多于5个\n\n特殊数值正零和负零正零和负零基本上与普通的0一致，唯一的区别是做分母时\n除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的\nNaN“非数字”（Not a Number）\n将字符串解析成数字出错会得到NaN\nconsole.log(5 - &#x27;x&#x27;); //NaN\n0/0得到NaN\nconsole.log(0 / 0); //NaN\n一些错误的数学运算也会出现NaN\nconsole.log(Math.sqrt(-1)); //NaNconsole.log(Math.log(-1)); //NaN\nNaN只是Number中的特殊数值，它的数据类型仍是number\nconsole.log(typeof NaN); //number\nNaN不等于任何值（包括它本身）\nconsole.log(NaN === NaN); //false\nNaN与任何数（包括它本身）的运算，得到的都是NaN\nInfinity等价于数学意义上的无穷，分正负\n特殊的：\nInfinity与NaN比较，总是返回false\nInfinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false\n0乘以Infinity等于NaN\n0 * Infinity // NaN\nInfinity减去或除以Infinity，等于NaN\nInfinity - Infinity // NaNInfinity / Infinity // NaN\nInfinity与null计算时，null会转成0，等同于与0的计算\nnull * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity\nInfinity与undefined计算，返回的都是NaN\nundefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN\n数值类型相关的方法parseInt()用法：将字符串转为整数\nconsole.log(parseInt(&quot;123&quot;));   //123\n若字符串首部有空格，会自动去掉空格\nconsole.log(parseInt(&quot;  345&quot;));   //345\n若传递的参数不是字符串，会先转为字符串再转为整数\nconsole.log(parseInt(1.23));   //1.23 -&gt; &quot;1.23&quot; -&gt; 1\njs是解释型语言，一个个字符依次转换，遇到不能转换的就直接结束，并返回已转换部分\nconsole.log(parseInt(&#x27;1a1&#x27;)); //1console.log(parseInt(&#x27;1.2&#x27;)); //1console.log(parseInt(&#x27;1.8&#x27;)); //1console.log(parseInt(&#x27;12*1&#x27;)); //12\n如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN\nconsole.log(parseInt(&#x27;abc&#x27;)); // NaNconsole.log(parseInt(&#x27;.3&#x27;)); // NaNconsole.log(parseInt(&#x27;&#x27;)); // NaNconsole.log(parseInt(&#x27;+&#x27;)); // NaNconsole.log(parseInt(&#x27;+1&#x27;)); // 1\n对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果\nconsole.log(parseInt(1000000000000000000000.5)); //1//等价于下面语句console.log(parseInt(&#x27;1e+21&#x27;)); //1console.log(parseInt(0.0000008)); //8//等价于下面语句console.log(parseInt(&#x27;8e-7&#x27;)); //8\nparseInt方法还可以接受第二个参数（2到36之间），表示被解析值的进制，默认是10\nconsole.log(parseInt(&quot;1000&quot;, 2)); //二进制的1000为：8（十进制）console.log(parseInt(&quot;1000&quot;, 8)); //八进制的1000为：512（十进制）console.log(parseInt(&quot;1000&quot;, 10)); //十进制的1000为：1000（十进制）console.log(parseInt(&quot;1000&quot;, 16)); //十六进制的1000为：4096（十进制）\n如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略\nconsole.log(parseInt(&#x27;10&#x27;, 37)); // NaNconsole.log(parseInt(&#x27;10&#x27;, 1)); // NaNconsole.log(parseInt(&#x27;10&#x27;, 0)); // 10console.log(parseInt(&#x27;10&#x27;, null)); // 10console.log(parseInt(&#x27;10&#x27;, undefined)); // 10\n如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN\nconsole.log(parseInt(&#x27;10136&#x27;, 2)); //转换到101, 101(bin) == 5(dec), return 5console.log(parseInt(&#x27;1369&#x27;, 8)); //转换到136, 136(oct) == 94(dec), return 94console.log(parseInt(&#x27;345&#x27;, 2)); //最高位无法转换，返回NaN\nparseFloat()将一个字符串转为浮点数，用法与parseInt()类似\n注意点：\n如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN\nconsole.log(parseFloat([])); //NaNconsole.log(parseFloat(&#x27;ABC123&#x27;)); //NaN\n空字符串转换为NaN\nconsole.log(parseFloat(&#x27;&#x27;)); //NaN\n区别于Number()函数\n\nNumber(object) 函数把对象的值转换为数字\n如果对象的值无法转换为数字，那么 Number() 函数返回 NaN\n\nconsole.log(parseFloat(true));  //NaNconsole.log(Number(true));  //1console.log(parseFloat(null));  //NaNconsole.log(Number(null));  //0console.log(parseFloat(&#x27;&#x27;));  //NaNconsole.log(Number(&#x27;&#x27;));  //0console.log(parseFloat(&#x27;123.45#&#x27;));  //123.45console.log(Number(&#x27;123.45#&#x27;));  //NaN\nisNaN()判断一个值是否为NaN\n注意：isNaN()仅对传入的参数为数值有效，否则会先转成数值。比如传入字符串、对象、数组时，会被先转成NaN，然后返回true。这一点也说明，isNaN()为true的不一定是NaN\nconsole.log(isNaN(&#x27;Hello&#x27;)); //true//相当于如下语句console.log(isNaN(Number(&#x27;Hello&#x27;))); //trueconsole.log(isNaN(&#123;&#125;)); //true//相当于如下语句console.log(isNaN(Number(&#123;&#125;))); //trueconsole.log(isNaN([&#x27;Hello&#x27;])); //true//相当于如下语句console.log(isNaN(Number([&#x27;Hello&#x27;]))); //true\n但是，对于空数组和只有一个数值成员的数组，isNaN()返回false\nconsole.log(isNaN([])); // falseconsole.log(isNaN([123])); // falseconsole.log(isNaN([&#x27;123&#x27;])); // false\n（这里可能不太理解为什么，isNaN()返回false，说明这些参数被Number()解析成数值而不是NaN，涉及到JavaScript中的数据类型转换相关知识，后续待补充…)\n上述可以看出，isNaN()并不能严格意义上判断出是否是NaN，若要严格判断，可利用NaN为唯一不等于自身的值的特点\nfunction realIsNaN(value) &#123;    return value !== value;&#125;console.log(realIsNaN(NaN)); //true\nisFinite()用法：判断传入的参数是否为有限数值\n\n被认为是“无限”的数值：Infinity、-Infinity、NaN、undefined\n注意：null被认为是有限的数值\n\nconsole.log(isFinite(Infinity)); // falseconsole.log(isFinite(-Infinity)); // falseconsole.log(isFinite(NaN)); // falseconsole.log(isFinite(undefined)); // falseconsole.log(isFinite(null)); // trueconsole.log(isFinite(-1)); // true\n字符串（string）没有什么特殊的点，JS中的字符串也是不可变的\n\nJavaScript中的原始值（null、undefined、数值、布尔值、字符串）的值都是不可改变的\n\n在 JavaScript 中没有char这种表示单个字符的类型。只有一种 string 类型，一个字符串可以包含零个（为空）、一个或多个字符\n引入方式在 JavaScript 中，有三种包含字符串的方式\n\n双引号：””\n单引号：’’\n反引号：``\n\n双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别\n反引号是 功能扩展 引号。它们允许我们通过将变量和表达式包装在 $&#123;…&#125; 中，来将它们嵌入到字符串中\nlet name = &quot;John&quot;;// 嵌入一个变量alert( `Hello, $&#123;name&#125;!` ); // Hello, John!// 嵌入一个表达式alert( `the result is $&#123;1 + 2&#125;` ); // the result is 3\n字符集JavaScript中使用的是Unicode字符集，允许在程序中使用Unicode码点（\\uxxxx）表示字符\nvar s = &#x27;\\u00A9&#x27;; // &quot;©&quot;console.log(s);\nvar f\\u006F\\u006F = &#x27;abc&#x27;; //也可用在变量名中console.log(foo); //&#x27;abc&#x27;\n在JavaScript中，所有的string类型都是使用UTF-16编码的\n对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。也就是说，JavaScript 返回的字符串长度可能是不正确的\n关于字符集和字符编码问题不太懂，有时间学习下再总结…\nBase64转码Base64是一种基于64个可打印字符来表示二进制数据的表示方法\n64个可打印字符：0～9、A～Z、a～z、+ 和 /\nBase64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据\n注意的是，Base64不是加密编码，而是为了不出现特殊字符，处理复杂数据从而简化程序处理\nJavaScript原生提供的两个Base64相关方法：\n\nbtoa()：任意值转为Base64编码\natob()：Base64编码转为原来的值\n\nvar str = &#x27;Hello JavaScript World!&#x27;;console.log(btoa(str)); //SGVsbG8gSmF2YVNjcmlwdCBXb3JsZCE=console.log(atob(btoa(str))); //Hello JavaScript World!\n注意：上述两个方法不适用于非ASCII码字符（需转码）\n对象（object）创建与属性基本var person = &#123;    name: &#x27;Alice&#x27;,    age: 20,    print: function () &#123;        console.log(&quot;name: &quot; + this.name + &quot;\\n&quot; + &quot;age: &quot; + this.age);    &#125;&#125;;//注意使用[]时要添加引号console.log(person[&#x27;name&#x27;]); //方括号运算符提取属性console.log(person[&#x27;age&#x27;]);person.print(); ////点运算符提取属性\n对象的键名都是字符串。若设置为数值，则会转成字符串。若不是数值也不符合标识的命名条件，则需加上引号，否则会报错\n提取对象的属性有两种方法：点运算符和方括号运算符\n注意：\n\n用方括号运算符时[]内要用引号\n对于对象的数值键名，不能用点运算符，会被当成小数点而报错，只能用方括号（不太理解键名设置为数值的意义…）\n\n对象的属性可以是任意的数据类型，属性还可动态创建\nvar person = &#123;&#125;; //声明一个无属性的person对象//对属性值直接赋值，动态创建person.name = &#x27;Alice&#x27;;person.age = 20;//前面提过，js中的函数也视作数据类型，可直接赋值person.print = function () &#123;    console.log(&quot;name: &quot; + this.name + &quot;\\n&quot; + &quot;age: &quot; + this.age);&#125;;person.print();\n属性的相关方法Object.keys()查看对象的所有属性\nconsole.log(Object.keys(person)); //[ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;print&#x27; ]\ndelete删除对象的属性，返回值为true或false\ndelete person.print; //trueconsole.log(Object.keys(person)); //[ &#x27;name&#x27;, &#x27;age&#x27; ]\n注意点：\n\ndelete删除一个本就不存在的属性时，也返回true。故不能根据delete结果来判断某个属性是否存在\nconsole.log(delete person.notexist); //true\n\ndelete只能删除对象本身的属性，无法删除继承的属性。即使执行结果返回true，但实际上这个属性还能使用，并没有真的删除。故不能根据delete结果来判断某个属性是否已被删除\nconsole.log(delete person.toString); //trueperson.toString();\n\n删除一个不能被删除的已存在属性时，返回false\n\nObject.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象\n\nvar person = Object.defineProperty(&#123;&#125;, &#x27;name&#x27;, &#123;    name: &#x27;Alice&#x27;,    age: 20,    print: function () &#123;        console.log(&quot;name: &quot; + this.name + &quot;\\n&quot; + &quot;age: &quot; + this.age);    &#125;&#125;);console.log(delete person.name); //false\n\n\nin检查对象中是否包含某个属性\n检查的是键名，不是键值\n能检查出继承的属性\nconsole.log(&#x27;name&#x27; in person); //trueconsole.log(&#x27;sex&#x27; in person); //falseconsole.log(&#x27;toString&#x27; in person); //true\nhasOwnProperty()判断某个属性是否为对象自身的属性\nconsole.log(person.hasOwnProperty(&#x27;name&#x27;)); //trueconsole.log(person.hasOwnProperty(&#x27;toString&#x27;)); //false\nfor…in遍历一个对象的全部属性\n注意：只会遍历出可以遍历的属性，例如继承的toString属性是不可遍历的\nfor (var key in person) &#123;    if (person.hasOwnProperty(key)) &#123;        console.log(&#x27;键名: &#x27;, key);        console.log(&#x27;键值: &#x27;, person[key]);    &#125;&#125;\n输出：\n键名:  name键值:  Alice键名:  age键值:  20键名:  print键值:  [Function: print]\nwith操作同一个对象的多个属性时，提供一些书写的便利\nwith (对象) &#123;  语句;&#125;\nwith(person) &#123;    sex = &#x27;man&#x27;; //sex属性不存在，此处并不会为person对象声明一个sex属性，而是创建一个当前作用域的全局变量&#125;console.log(person.sex); //undefinedconsole.log(sex); //man\nwith (obj) &#123;  console.log(x);&#125;\n弊端：绑定对象不明确，无法判断x是全局变量还是对象的属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度，建议不使用with语句\nwith(obj1.obj2.obj3) &#123;  console.log(p1 + p2);&#125;// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2);\n引用与值拷贝对象的引用相关概念与Java类似\nJavaScript中原始数据类型（数值、布尔值、字符串、null、undefined）不存在引用的概念，是值拷贝\n函数（function）基本概念函数的声明第一种方式：\nfunction print(s) &#123;  console.log(s);&#125;\n第二种方式：\nvar print = function(s) &#123;  console.log(s);&#125;;\nvar f = function f() &#123;&#125;;\n第三种方式：\nvar add = new Function(  &#x27;x&#x27;,  &#x27;y&#x27;,  &#x27;return x + y&#x27;);// 等同于function add(x, y) &#123;  return x + y;&#125;\n第一等公民\nJavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处\n\n由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民\n函数名的提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部，类比于变量提升\n所以，下面的代码不会报错\nf();function f() &#123;&#125;\n但是，如果采用赋值语句定义函数，JavaScript 就会报错\nf();var f = function ()&#123;&#125;;// TypeError: undefined is not a function\n等价于：\nvar f;f();f = function () &#123;&#125;;\n分析：\n上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错\n再看一个例子：\nvar f = function () &#123;  console.log(&#x27;1&#x27;);&#125;function f() &#123;  console.log(&#x27;2&#x27;);&#125;f() // 1\n由于函数提升，输出2的被提到前面去了，然后输出1的函数覆盖了该函数，所以最终输出1\n函数的属性和方法name属性返回函数的名字\nlength属性返回函数预期传入的参数个数\nlength属性与实际传入的参数个数无关，只反映函数预期传入的参数个数\nlength属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）\ntoString()方法返回一个字符串，内容是函数的源码，包含内部的注释信息\n对于那些原生的函数，toString()方法返回function ()&#123;[native code]&#125;\nconsole.log(Math.sqrt.toString()); //function sqrt() &#123; [native code] &#125;\n函数作用域ES5标准，有两种函数作用域：全局作用域、函数作用域（ES6中新增块级作用域）\n注意函数作用域只有在函数内部，条件判断语句等内部不算函数作用域，被视作全局变量\nif (true) &#123;  var x = 5;&#125;console.log(x);  // 5\n函数内部的变量提升var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部\n函数本身的作用域函数也是一种数据类型，可视作变量，也有自身的作用域\n函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域\nvar a = 1;var x = function () &#123;  console.log(a);&#125;;function f() &#123;  var a = 2;  x();&#125;f() // 1\n上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2\n参数可省略JavaScript允许省略参数，被省略的参数为undefined\n省略参数不改变函数的length属性值，因为length属性值只反映函数预期传入的参数个数\nfunction f(a, b) &#123;  return a;&#125;f(1, 2, 3) // 1f(1) // 1f() // undefinedf.length // 2\n注意，不能省略靠前的参数，如果必须省略，则需要显式地传入undefined\nfunction f(a, b) &#123;  return a;&#125;f( , 1) // SyntaxError: Unexpected token ,(…)f(undefined, 1) // undefined\narguments 对象由于参数可省略且不定长，所以需要一种机制来读取函数体的所有参数，包括省略的参数，于是就有了arguments 对象，它包含了函数在运行时的所有参数。这个对象只有在函数体内部才能使用\nvar f = function (a, b) &#123;    console.log(arguments[0]);    console.log(arguments[1]);    console.log(arguments[2]);&#125;f(1); //1 undefined undefinedf(1, 2); //1 2 undefinedf(1, 2, 3, 4); //1 2 3\n通过arguments对象的length属性，可以判断函数调用时到底带几个参数\nfunction realLength() &#123;    return arguments.length;&#125;console.log(realLength()); //0console.log(realLength(1)); //1console.log(realLength(1, 2)); //2console.log(realLength(1, 2, 3)); //3\narguments对象还有一个callee属性，返回它所对应的原函数\nvar myself = function () &#123;    console.log(arguments.callee === myself);&#125;myself() // true\n可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用\n值传递与引用传递原始数据类型（数值、布尔值、字符串、null、undefined）属于值传递（passes by value）\n复合类型的值（数组、对象、其他函数）属于引用传递（pass by reference）\n注意：如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值\nvar obj = [1, 2, 3];function changeAll(o) &#123;    o = [2, 3, 4];&#125;changeAll(obj);console.log(obj.toString()); //1,2,3\n对比如下操作：\nvar obj = [1, 2, 3];function changePart(o) &#123;    o[0] = 4;    o[1] = 5;    o[2] = 6;&#125;changePart(obj);console.log(obj.toString()); //4,5,6\n通过内存分析来解释JavaScript数组赋值问题\n立即调用(IIFE)(function () &#123;    console.log(&quot;Hello World!&quot;);&#125;())//等价于下面写法(function () &#123;    console.log(&quot;Hello World!&quot;);&#125;)()\n通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：\n\n不必为函数命名，避免了污染全局变量\nIIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量\n\n// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () &#123;  var tmp = newData;  processData(tmp);  storeData(tmp);&#125;());\n上面代码中，写法二比写法一更好，因为完全避免了污染全局变量\neval()函数将传入的字符串当做JavaScript代码进行执行\n弊端：\n\n性能不好，不利于引擎优化执行速度\n不安全，可能会修改当前作用域的变量值\n产生混乱的代码逻辑\n\n避免使用eval()函数\n话说eval()函数既然这么多弊端，那么它的具体使用场景有哪些呢？接触到的时候再说吧…\n数组(array)数组就是一种特殊的对象（object），有关它对象方面的特点不再阐述\n下面记录一些自己觉得有必要记录的：\nlength属性数组的length属性是可写的\nvar arr = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ];arr.length // 3arr.length = 2;arr // [&quot;a&quot;, &quot;b&quot;]\n利用这点，可实现清空数组，即将length属性设为0\nvar arr = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ];arr.length = 0;arr // []\n如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位，数据类型为undefined\nvar a = [&#x27;a&#x27;];a.length = 3;a[1] // undefined\n数组的空位元素当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）\nvar a = [1, , 1];a.length // 3\n上述代码可见，数组的空位不影响length属性\n注意：如果最后一个元素后面有逗号，不会在末尾产生空位\nvar a = [1, 2, 3,];a.length // 3a // [1, 2, 3]\n使用delete命令删除一个数组成员时，会形成空位\nvar arr = [1, 2, 3, 4, 5];delete arr[2];//遍历返回：1 2 undefined 4 5for (var i = 0; i &lt; arr.length; i++) &#123;    console.log(arr[i]);&#125;\n接下来是一个比较迷惑的点：空位和undefined\n空位和undefined数组的空位是可读取的，返回的是undefined\nvar arr = [1, , 3];console.log(arr[1]); //undefined\n数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过\nvar a = [, , ,];a.forEach(function (x, i) &#123;  console.log(i + &#x27;. &#x27; + x);&#125;)// 不产生任何输出for (var i in a) &#123;  console.log(i);&#125;// 不产生任何输出Object.keys(a)// []\n但如果某个位置是undefined，遍历的时候就不会被跳过\nvar a = [undefined, undefined, undefined];a.forEach(function (x, i) &#123;  console.log(i + &#x27;. &#x27; + x);&#125;);// 0. undefined// 1. undefined// 2. undefinedfor (var i in a) &#123;  console.log(i);&#125;// 0// 1// 2Object.keys(a)// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]\n理解：空位即没有元素，所以不会被遍历到；undefined显式写出，则表示这个元素的值是undefined，所以会被遍历到\n但是，读取空位上的元素时又会返回undefined\n还有一些奇奇怪怪的玩意儿就不记录了，话说我总觉得那些奇怪的玩意儿应该没什么人会那样子用吧，总之遇到再学习吧…\nReferenceshttps://wangdoc.com/javascript/types/index.html\nhttps://zh.javascript.info/types\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"Java集合框架","url":"/2021/02/05/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","content":"本篇从总揽全局的视角对Java中的集合框架进行了一个大体的阐述，包括List、Set、Map三大接口\n\n基本概念集合是由若干个确定的元素所构成的整体，集合框架是一个用来代表和操纵集合的统一架构\n很容易想到，数组可以看作是一种集合，那为什么还需要有集合框架呢？\n因为数组有它的使用局限性：容量固定、只能按索引顺序存取\n集合框架被设计成要满足以下几个目标：\n\n该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的\n该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性\n对一个集合的扩展和适应必须是简单的\n\n所有的集合框架都包含如下内容：\n\n接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象\n\n\n实现类：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap\n算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现\n\n\n从上图可看出，Java集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合；另一种是图（Map），存储键值对映射。它们都在java.util包下\n集合与数组的区别\n容量：集合的容量不固定，可以在新增或移除元素时自动的增加或缩减其容量；数组的容量在声明时就固定了\n数据类型：集合只能存储引用类型的数据（Integer、Long、Double…），而数组既可以存储基本数据类型（int、long、double…）也能存储引用数据类型\n\n无序性和不可重复性讨论接口前先对无序性和不可重复性进行一个说明，以便更好地理解不同接口的特性\n无序性：无序≠随机，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的\n不可重复性：指添加的元素按照equals()判断时 ，返回false，需要同时重写equals()方法和HashCode()方法\nCollection接口上面了解到，集合框架包括三方面的内容：接口、实现类和算法\n本篇就先讨论Java集合框架中常用接口的使用\n对于集合框架定义的接口中，Collection接口是最基本的集合接口，代表一组Object，存储一组可重复、无序的对象，且没有下标，即不能通过索引来访问集合中的元素\n常用方法\nboolean add(E e)    添加元素\nint size()    返回集合中元素个数\nboolean remove(Object o)    删除指定元素\nboolean clear()    删除所有元素\nIterator&lt;E&gt; iterator    返回此集合中的元素迭代器\nboolean contains(Object o)    判断是否包含指定元素\nboolean isEmpty()    判断集合是否为空\n\npackage collection;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;/** * Collection接口的常用方法： * 添加 * 删除 * 遍历 * 判断 */public class CollectionDemo &#123;    public static void main(String[] args) &#123;        //创建集合        Collection collection = new ArrayList();                //1. 添加元素        collection.add(&quot;《晴天》&quot;);        collection.add(&quot;《花海》&quot;);        collection.add(&quot;《轨迹》&quot;);        collection.add(&quot;《轨迹》&quot;); //可重复        //获取集合中元素个数        System.out.println(&quot;当前集合中的元素个数：&quot; + collection.size());        //打印集合中所有元素        System.out.println(collection.toString());        //2. 删除元素        collection.remove(&quot;《轨迹》&quot;);        System.out.println(&quot;删除后：&quot;);        System.out.println(&quot;当前集合中的元素个数：&quot; + collection.size());        System.out.println(collection);        //清空        collection.clear();        System.out.println(&quot;清空后：&quot;);        System.out.println(&quot;当前集合中的元素个数：&quot; + collection.size());        System.out.println(collection);        System.out.println(&quot;再度添加元素...&quot;);        collection.add(&quot;《晴天》&quot;);        collection.add(&quot;《花海》&quot;);        collection.add(&quot;《轨迹》&quot;);        //3. 遍历元素【重点】        /*         * 两种方式：         * 1. 使用foreach，不能使用for的原因是：collection没有提供下标         * 2. 使用迭代器         */        System.out.println(&quot;foreach遍历集合中的元素：&quot;);        for (Object object : collection) &#123;            System.out.println(object);        &#125;        /*         * hasNext(); return boolean 判断是否有下一个元素         * next(); return E 返回迭代器中的下一个元素         * remove(); return void 删除当前元素         */        System.out.println(&quot;使用迭代器遍历集合中的元素：&quot;);        Iterator iterator = collection.iterator();        while (iterator.hasNext()) &#123;            String song = (String) iterator.next();            System.out.println(song);            //使用迭代器时不能并发修改，不能使用迭代器以外的方法去修改集合中的元素            //代码&quot;collection.remove(song);&quot;报错:java.util.ConcurrentModificationException            //collection.remove(song);            //可以使用迭代器自带的remove()方法修改集合元素            iterator.remove();        &#125;        System.out.println(&quot;使用迭代器遍历并删除集合中元素后：&quot;);        System.out.println(&quot;当前集合中的元素个数：&quot; + collection.size());        System.out.println(collection);        System.out.println(&quot;再度添加元素...&quot;);        collection.add(&quot;《晴天》&quot;);        collection.add(&quot;《花海》&quot;);        collection.add(&quot;《轨迹》&quot;);        //4. 判断        System.out.println(collection.contains(&quot;《晴天》&quot;));        System.out.println(collection.isEmpty());    &#125;&#125;\nList接口List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置\nList接口存储一组有序、可重复的对象，有下标，即可以通过索引来访问List中的元素\n常用方法List接口是Collection接口的子接口\n\nint indexOf(Object o)    返回列表中指定元素的第一次出现的索引，若不包含此元素则返回-1\nE remove(int index)    删除指定索引处的元素\nE set(int index, E element)    用指定的元素替换指定位置的元素\nList&lt;E&gt; subList(int fromIndex, int toIndex)    返回指定区间内的子列表，注意左闭右开\nListIterator&lt;E&gt; listIterator()    返回列表迭代器\nvoid add(E e) 将指定的元素插入列表\nboolean hasPrevious() 是否存在上一个元素（用于反向遍历）\nint nextIndex() 返回下一个元素的索引下标\nE previous() 返回上一个元素，并将指针前移一位\nint previousIndex() 返回上一个元素的索引下标\nvoid set(E e) 设置元素值（用于替换）\n\n\n\npackage collection;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.ListIterator;/** * List接口的常用方法： * 添加 * 删除 * 遍历 * 判断 */public class ListDemo &#123;    public static void main(String[] args) &#123;        //创建集合        List list = new ArrayList&lt;&gt;();        //1. 添加元素        list.add(&quot;《晴天》&quot;);        list.add(&quot;《花海》&quot;);        list.add(&quot;《轨迹》&quot;);        list.add(&quot;《轨迹》&quot;);   //可重复        System.out.println(&quot;当前集合中的元素个数：&quot; + list.size());        System.out.println(list.toString());        //2. 删除元素        list.remove(&quot;《花海》&quot;);        list.remove(0); //按索引删除        System.out.println(&quot;删除元素后：&quot;);        System.out.println(&quot;当前集合中的元素个数：&quot; + list.size());        System.out.println(list.toString());        System.out.println(&quot;再度添加元素...&quot;);        list.add(&quot;《晴天》&quot;);        list.add(&quot;《花海》&quot;);        //3. 遍历元素        //遍历方式一：使用for循环，因为list提供了索引下标，故可以使用for循环方式来遍历元素        System.out.println(&quot;使用for循环遍历元素：&quot;);        for (int i = 0; i &lt; list.size(); i++) &#123;            System.out.println(list.get(i));        &#125;        //遍历方式二：使用foreach        System.out.println(&quot;使用foreach遍历元素：&quot;);        for (Object object : list) &#123;            System.out.println(object);        &#125;        //遍历方式三：使用迭代器        System.out.println(&quot;使用迭代器方式遍历元素：&quot;);        Iterator iterator = list.iterator();        while (iterator.hasNext()) &#123;            System.out.println(iterator.next());        &#125;        //遍历方式四：使用列表迭代器        /*         * 列表迭代器允许程序员沿任一方向遍历列表，它的功能比Iterator更丰富，除了hasNext()、next()、remove()方法外，还提供了以下方法：         * void add(E e) 将指定的元素插入列表         * boolean hasPrevious() 是否存在上一个元素（用于反向遍历）         * int nextIndex() 返回下一个元素的索引下标         * E previous() 返回上一个元素，并将指针前移一位         * int previousIndex() 返回上一个元素的索引下标         * void set(E e) 设置元素值（用于替换）         */        ListIterator listIterator = list.listIterator();        System.out.println(&quot;使用列表迭代器正向遍历元素：&quot;);        while (listIterator.hasNext()) &#123;            System.out.println(listIterator.nextIndex() + &quot;: &quot; + listIterator.next());        &#125;        System.out.println(&quot;使用列表迭代器反向遍历元素：&quot;);        while (listIterator.hasPrevious()) &#123;            System.out.println(listIterator.previousIndex() + &quot;: &quot; + listIterator.previous());        &#125;        //测试set(E e)方法的使用        while (listIterator.hasNext()) &#123;            //将歌曲《轨迹》替换成《稻香》            if (listIterator.next().equals(&quot;《轨迹》&quot;)) &#123;                listIterator.set(&quot;《稻香》&quot;);            &#125;        &#125;        System.out.println(&quot;将歌曲《轨迹》替换成《稻香》：&quot;);        System.out.println(list.toString());        //测试indexOf()方法的使用        System.out.println(&quot;《稻香》的索引下标为：&quot; + list.indexOf(&quot;《稻香》&quot;));   //可见当存在多个对象值时，indexOf总是返回第一个元素出现的位置        //4. 判断        System.out.println(list.contains(&quot;《稻香》&quot;));        System.out.println(list.isEmpty());    &#125;&#125;\n补充一些额外的注意事项及使用方法\npackage collection;import java.util.ArrayList;import java.util.List;/** * 补充说明一些有关List集合的内容 */public class ListDemoAdd &#123;    public static void main(String[] args) &#123;        List list = new ArrayList&lt;&gt;();        /*         * 前面提过，集合中存储的都是引用数据类型         * 所以集合中添加基本数据类型时，会有一个自动装箱的过程         */        list.add(10);        list.add(20);        list.add(30);        list.add(40);        list.add(50);        System.out.println(&quot;当前集合中的元素个数：&quot; + list.size());        System.out.println(list.toString());        //注意，此时使用删除操作时，比如要想删除元素30，不能直接remove(30)        //list.remove(30);不可取，因为30会被识别为索引值        //一种方法是，直接根据索引来删除        /*list.remove(2);    //30在集合中的索引是2        System.out.println(&quot;删除元素后：&quot;);        System.out.println(&quot;当前集合中的元素个数：&quot; + list.size());        System.out.println(list.toString());*/        //另一种方法是，装箱后删除        //list.remove((Object) 30);        //或者下面这种方式装箱        list.remove(new Integer(30));        System.out.println(&quot;删除元素后：&quot;);        System.out.println(&quot;当前集合中的元素个数：&quot; + list.size());        System.out.println(list.toString());        //方法subList(int fromIndex, int toIndex)的使用，此方法返回列表的子列表        //注意，子列表接受的参数区间是左闭右开区间        List subList = list.subList(1, 3); //即这里包含了索引1处的元素，但不包含索引3处的元素        System.out.println(&quot;子列表：&quot; + subList.toString());    &#125;&#125;\nSet接口\n 不包含重复元素的集合。更正式地，集合不包含一对元素e1和e2  ，使得e1.equals(e2) ，并且最多一个空元素\n\nSet具有与Collection完全一样的接口，只是行为上不同，Set 不保存重复的元素\nSet接口存储一组无序、不可重复的对象，且没有下标，即不能通过索引来访问集合中的元素\n常用方法上面说了，Set具有与Collection完全一样的接口，只是行为上不同，具体参考代码样例\npackage collection;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class SetDemo &#123;    public static void main(String[] args) &#123;        //创建集合        Set set = new HashSet();        //验证无序性        set.add(&quot;Java&quot;);        set.add(&quot;C++&quot;);        set.add(&quot;Python&quot;);        set.add(&quot;C&quot;);        /*         * 输出：         * Java         * C++         * C         * Python         */        /**         * Set集合的无序性是指：添加元素的顺序和迭代的顺序不是一致的         * 但是，这并不是说输入的顺序一定就和输出的顺序不一致         * Set集合在存储元素时有它自己的一套规则，有可能出现输入顺序和输出顺序一致，但这也不意味着Set是有序的         */        System.out.println(&quot;当前集合中的元素个数：&quot; + set.size());        System.out.println(&quot;使用迭代器遍历元素：&quot;);        Iterator iterator = set.iterator();        while (iterator.hasNext()) &#123;            System.out.println(iterator.next());        &#125;        //验证不可重复性        set.add(&quot;Java&quot;);        set.add(&quot;C++&quot;);        System.out.println(set);        //特别的，Set中只允许出现一次null        set.add(null);        set.add(null);        set.add(null);        System.out.println(set);    &#125;&#125;\nMap接口Map 接口存储一组键值对象，提供key（键）到value（值）的映射\nMap不能包含重复的键，每个键可以映射到最多一个值\n键：无序、无下标、不允许重复\n值：无序、无下标、允许重复\n常用方法\nV put(K key, V value)    向Map中添加键值对映射\nV get(Object key)    返回指定key对应的value值\nboolean containsKey(Object key)    判断是否包含指定key的映射\nboolean containsValue(Object value)    判断是否包含指定value值\nSet&lt;K&gt; keySet()    返回Map中包含的key的Set集合\nSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()    返回Map中包含的键值对的Set集合\n\npackage collection;import java.util.HashMap;import java.util.Map;public class MapDemo &#123;    public static void main(String[] args) &#123;        //创建集合        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        //添加元素        map.put(&quot;北京&quot;, &quot;京&quot;);        map.put(&quot;上海&quot;, &quot;沪&quot;);        map.put(&quot;广东&quot;, &quot;粤&quot;);        System.out.println(&quot;当前集合元素个数：&quot; + map.size());        System.out.println(map.toString());        //删除元素        map.remove(&quot;上海&quot;);        System.out.println(&quot;删除后：&quot;);        System.out.println(&quot;当前集合元素个数：&quot; + map.size());        System.out.println(map.toString());        //清空集合        map.clear();        System.out.println(&quot;清空后：&quot;);        System.out.println(&quot;当前集合元素个数：&quot; + map.size());        System.out.println(map.toString());        //重新添加        System.out.println(&quot;重新添加元素...&quot;);        map.put(&quot;北京&quot;, &quot;京&quot;);        map.put(&quot;上海&quot;, &quot;沪&quot;);        map.put(&quot;广东&quot;, &quot;粤&quot;);        //遍历元素【重点】        /*         * 方法一：使用keySet()         * 由于返回的是一个Set集合，故可使用遍历Set集合的方法去遍历结果集         * 即：foreach或迭代器         * Set集合中只存储了key值，要获取value值还需要使用get(Object key)方法         */        System.out.println(&quot;使用keySet()方式遍历元素：&quot;);        for (String key : map.keySet()) &#123;            System.out.println(key + &quot;: &quot; + map.get(key));        &#125;        /*         * 方法二：使用entrySet()         * 返回的也是Set集合，只不过Set集合中存储的是entry即键值对         */        System.out.println(&quot;使用entrySet()方式遍历元素：&quot;);        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;            System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());        &#125;        //判断        System.out.println(map.containsKey(&quot;北京&quot;));        System.out.println(map.containsValue(&quot;粤&quot;));        System.out.println(map.isEmpty());    &#125;&#125;\n总结List：有序、可重复\nSet：无序、不可重复\nMap：键（Key）无序、不可重复；值（Value）无序、可重复\nReferenceshttps://www.runoob.com/java/java-collections.html\nhttps://www.bilibili.com/video/BV1zD4y1Q7Fw?p=1\n","categories":["Java"],"tags":["集合框架"]},{"title":"Software Testing","url":"/2019/05/26/SoftwareTest/","content":"Some messy concepts about software testing.\n\nSoftware Faults, Errors and Failures\nFault – It is a condition that causes the software to fail to perform its required function. \nError – Refers to difference between Actual Output and Expected output. \nFailure –  It is the inability of a system or component to perform required function according to its specification. \n\npublic int findLast (int [ ] x,int y)&#123;  // Effects: If x is null throw NullPointerException   // else return the index of last element in x that equals y.   // if no such element exists,return -1.   int count = 0;   for (int i = x.length-1; i &gt; 0 ; i--)   &#123;      if (x [ i ] == y)      &#123;         return i;      &#125;   &#125;   return -1;&#125;\nIn the for loop, because i &gt; 0 is not satisfied when i = 0, it is impossible to traverse to i = 0, so there is actually no comparison of the first number. This is our fault.\n\nWhen the test case is : x = [], a null pointer exception is thrown. At this time, the following program is not executed, so no fault is executed.\n\nWhen the test case is : x = [2,3,5], y = 3\n\n\nExpected value: 1 Actual value: 1 Since we returned correctly when i = 1. So although we executed the program with fault, but did not generate an error, so the fault was executed and no error was executed.\n\nWhen the test case is : x = [2,3,5], y = 1\n\nExpected value: -1 Actual value: -1 Although we got the correct result, by design, we should return -1 after traversing x = 0; and the actual program returns -1 directly after traversing x = 1. So the fault was executed and the error was generated, but the failure did not occur.\n\nWhen the test case is : x = [2,3,5], y = 2\n\nExpected value: 0 Actual value: -1 We get the result that is inconsistent with the expectation. According to the design, we should return 0 after traversing x = 0. The actual program returns -1 directly after traversing x = 1, so execute The fault, which produced an error, also produced a failure.\nVerification and Validation\n\n\n\nVerification\nValidation\n\n\n\n\nAre we building the system right?\nAre we building the right system?\n\n\nThe process of determining whether the products of a given phase of the software development process fulfill the requirements established during the previous phase\nThe process of evaluating software at the end of software development to ensure compliance with intended usage\n\n\nThe objective of Verification is to make sure that the product being develop is as per the requirements and design specifications.\nThe objective of Validation is to make sure that the product actually meet up the user’s requirements, and check whether the specifications were correct in the first place.\n\n\nFollowing activities are involved in Verification: Reviews, Meetings and Inspections.\nFollowing activities are involved in Validation: Testing like black box testing, white box testing, gray box testing etc.\n\n\n\n\nTesting Goals Based on Test Process Maturity\nLevel 0 : There’s no difference between testing and debugging\nLevel 1 : The purpose of testing is to show correctness\nLevel 2 : The purpose of testing is to show that the software doesn’t work\nLevel 3 : The purpose of testing is not to prove anything specific, but to reduce the risk of using the software\nLevel 4 : Testing is a mental discipline that helps all IT professionals develop higher quality software\n\nWhat is Software testing?Testing is the process of evaluating a system or its components with the intent to find whether it satisfies the specified requirements or not.In simple words, testing is executing a system in order to identify any gaps, errors, or missing requirements in contrary to the actual requirements. Testing can be defined as - A process of analyzing a software item to detect the differences between existing and required conditions (that is defects/errors/bugs) and to evaluate the features of the software item.\nWhy Do We Test Software ?Software Testing is necessary because the existence of faults in software is inevitable. \n\nImprove qualityIt is very important to ensure the Quality of the product. Quality product delivered to the customers helps in gaining their confidence.Poor quality in software can be hazardous to human life and safety. Quality problems can impact the functionality of the software products. \nReduce costTesting is the most time consuming and expensive part of software development. Not testing is even more expensive. If we have too little testing effort early, the cost of testing increases. Planning for testing after development is prohibitively expensive.\nPreserve customer satisfactionTesting can bring good products, good products can get user satisfaction and support, in order to expand our product market.\n\nComplexity of Testing SoftwareSoftware complexity is a way to describe a specific set of characteristics of your code. It includes time complexity, space complexity.Just like how long it takes for this test program to run, how much memory does this program take up?\nData AbstractionData abstraction is the reduction of a particular body of data to a simplified representation of the whole. Abstraction, in general, is the process of taking away or removing characteristics from something in order to reduce it to a set of essential characteristics. Like other engineers, we must use abstraction to manage complexity. This is the purpose of the model-driven test design process. The “model” is an abstract structure.\nCoverage CriteriaEven small programs have too many inputs to fully test them all. Testers search a huge input space. Trying to find the fewest inputs that will find the most problems. Coverage criteria are usually defined as rules or requirements, which a test suite needs to satisfy. Coverage criteria give structured, practical ways to search the input space.\nAdvantages of Coverage Criteria: \n\nMaximize the “bang for the buck”\nMake regression testing easier\nGives testers a “stopping rule” … when testing is finished\nCan be well supported with powerful tools\n\nRegression TestingRegression Testing is defined as a type of software testing to confirm that a recent program or code change has not adversely affected existing features.Regression Testing is nothing but a full or partial selection of already executed test cases which are re-executed to ensure existing functionalities work fine.This testing is done to make sure that new code changes should not have side effects on the existing functionalities. It ensures that the old code still works once the new code changes are done.\nTest AutomationIn software testing, test automation is the use of software separate from the software being tested to control the execution of tests and the comparison of actual outcomes with predicted outcomes. Test automation can automate some repetitive but necessary tasks in a formalized testing process already in place, or perform additional testing that would be difficult to do manually. \nBlack-box testing &amp; White-box testing &amp; Model-based testing\nBlack-box testing : Derive tests from external descriptions of the software, including specifications, requirements, and design\nWhite-box testing : Derive tests from the source code internals of the software, specifically including branches, individual conditions, and statements\nModel-based testing : Derive tests from a model of the software (such as a UML diagram)\n\nModel-based testingLike other engineers, we must use abstraction to manage complexity. This is the purpose of the model-driven test design process. The “model” is an abstract structure.The Model-Driven Test Design (MDTD) process breaks testing into a series of small tasks that simplify test generation. \nTesting can be broken up into four general types of activities\nTest Design\n\n\nCriteria-based\nHuman-based\n\n\nTest Automation\nTest Execution\nTest Evaluation\n\nAgile TestingA software testing practice that follows the principles of agile software development is called Agile Testing.\nAgile is an iterative development methodology, where requirements evolve through collaboration between the customer and self-organizing teams and agile aligns development with customer needs.\nAdvantages of Agile Testing: \n\nAgile Testing Saves Time and Money \nLess Documentation\nRegular feedback from the end user\nDaily meetings can help to determine the issues well in advance\n\nPrinciples of Agile Testing: \n\nTesting is NOT a Phase\nTesting Moves the project Forward\nEveryone Tests\nShortening Feedback Response Time \nClean Code\nReduce Test Documentation\nTest Driven\n\nWhat is JunitJUnit is an open source Unit Testing Framework for JAVA. It is useful for Java Developers to write and run repeatable tests. It is used for Unit Testing of a small chunk of code. Once you are done with code, you should execute all tests, and it should pass. Every time any code is added, you need to re-execute all test cases and makes sure nothing is broken.\nWhat is FrameworkA framework is a real or conceptual structure intended to serve as a support or guide for the building of something that expands the structure into something useful.\nWhat is Unit TestingUnit Testing is used to verify a small chunk of code by creating a path, function or a method. The term “unit” exist earlier than the object-oriented era. It is basically a natural abstraction of an object oriented system i.e. a Java class or object (its instantiated form).\nThe fixtures and annotations in Junitpublic class BasicAnnotationTest &#123;    // Run once, e.g. Database connection, connection pool    @BeforeClass    public static void runOnceBeforeClass() &#123;        System.out.println(&quot;@BeforeClass - runOnceBeforeClass&quot;);    &#125;    // Run once, e.g close connection, cleanup    @AfterClass    public static void runOnceAfterClass() &#123;        System.out.println(&quot;@AfterClass - runOnceAfterClass&quot;);    &#125;    // Should rename to @BeforeTestMethod    // e.g. Creating an similar object and share for all @Test    @Before    public void runBeforeTestMethod() &#123;        System.out.println(&quot;@Before - runBeforeTestMethod&quot;);    &#125;    // Should rename to @AfterTestMethod    @After    public void runAfterTestMethod() &#123;        System.out.println(&quot;@After - runAfterTestMethod&quot;);    &#125;    @Test    public void test_method_1() &#123;        System.out.println(&quot;@Test - test_method_1&quot;);    &#125;    @Test    public void test_method_2() &#123;        System.out.println(&quot;@Test - test_method_2&quot;);    &#125;&#125;\nOutput is: \n\n@BeforeClass - runOnceBeforeClass@Before - runBeforeTestMethod@Test - test_method_1@After - runAfterTestMethod@Before - runBeforeTestMethod@Test - test_method_2@After - runAfterTestMethod@AfterClass - runOnceAfterClass\n\nCode-refactoringCode refactoring is the process of restructuring existing computer code—changing the factoring—without changing its external behavior. Refactoring is intended to improve nonfunctional attributes of the software. Advantages include improved code readability and reduced complexity; these can improve source-code maintainability and create a more expressive internal architecture or object model to improve extensibility.\nCode-IntegrationCode Integration is a development practice where developers integrate code into a shared repository frequently, preferably several times a day. Each integration can then be verified by an automated build and automated tests. While automated testing is not strictly part of CI it is typically implied. One of the key benefits of integrating regularly is that you can detect errors quickly and locate them more easily. As each change introduced is typically small, pinpointing the specific change that introduced a defect can be done quickly.\nTraceabilityTraceability refers to a document in software testing which intends to establish relationship among various factors. It helps to determine the completeness of a given relationship by comparing the baselined documents(business and technical). Traceability check is done by preparing a tabular representation of data (test cases). Traceability may vary from mapping requirements to components, test conditions with test scripts or test cases.\nTest EvaluationTest Evaluation is the process by which a system or components are compared against requirements and specifications through testing. In order to correctly evaluate a test, at least four attributes should be measured: namely, sensitivity, specificity, accuracy and precision.\nSeleniumSelenium is a free (open source) automated testing suite for web applications across different browsers and platforms. It is quite similar to HP Quick Test Pro (QTP now UFT) only that Selenium focuses on automating web-based applications. Testing done using Selenium tool is usually referred as Selenium Testing.\nSelenium is not just a single tool but a suite of software’s, each catering to different testing needs of an organization. It has four components.\n\nSelenium Integrated Development Environment (IDE)\nSelenium Remote Control (RC)\nWebDriver\nSelenium Grid\n\nWebDriver is an interface provided by Selenium WebDriver. As we know that interfaces in Java are the collection of constants and abstract methods(methods without any implementation). The WebDriver interface serves as a contract that each browser specific implementation like ChromeDriver, FireFoxDriver must follow.\nWhat is the advantage and disadvantage of using Selenium Testing Tool?Advantages: \n\nSelenium is pure open source, freeware and portable tool. \nSelenium supports variety of languages that include Java, Perl, Python, C#, Ruby, Groovy, Java Script, and VB Script. etc. \nSelenium supports many operating systems like Windows, Macintosh, Linux, Unix etc. \nSelenium supports many browsers like Internet explorer, Chrome, Firefox, Opera, Safari etc. \nSelenium can be integrated with TestNG testing framework for testing our applications and generating reports. \nSelenium can be integrated with other open source tools for supporting other features. \nSelenium can be used for Android, IPhone, Blackberry etc. based application testing. \n\nDisadvantages: \n\nSelenium needs very much expertise resources. The resource should also be very well versed in framework architecture. \nSelenium only supports web based application and does not support windows based application. \nIt is difficult to test Image based application. \nSelenium need outside support for report generation activity like dependence on TestNG or Jenkins. \nSelenium does not support built in add-ins support. \nSelenium user lacks online support for the problems they face. \nSelenium script creation time is bit high. \nSelenium does not support file upload facility. \nSelenium partially supports for Dialog boxes.\n\nTDDTDD can be defined as a programming practice that instructs developers to write new code only if an automated test has failed. This avoids duplication of code. TDD means “Test Driven Development”. The primary goal of TDD is to make the code clearer, simple and bug-free.\nTest-Driven Development starts with designing and developing tests for every small functionality of an application. In TDD approach, first, the test is developed which specifies and validates what the code will do.\nIn the normal Software Testing process, we first generate the code and then test. Tests might fail since tests are developed even before the development. In order to pass the test, the development team has to develop and refactors the code. Refactoring a code means changing some code without affecting its behavior.\nThe simple concept of TDD is to write and correct the failed tests before writing new code (before development). This helps to avoid duplication of code as we write a small amount of code at a time in order to pass tests. (Tests are nothing but requirement conditions that we need to test to fulfill them).\nSoftware ArtifactIn software development life cycle (SDLC), artifact usually refers to “things” that are produced by people involved in the process. Examples would be design documents, data models, workflow diagrams, test matrices and plans, setup scripts, … like an archaeological site, any thing that is created could be an artifact.\nAcceptance TestingAcceptance Testing is a level of software testing where a system is tested for acceptability. The purpose of this test is to evaluate the system’s compliance with the business requirements and assess whether it is acceptable for delivery.\n\nUnit Testing —-&gt; Integration Testing —-&gt; System Testing —-&gt; Acceptance Testing\n\nAcceptance Testing is the fourth and last level of software testing performed after System Testing and before making the system available for actual use.\nObservabilityObservability determines the work it takes to set up and run test cases and the extent to which the response of the system under test (SUT) to test cases can be verified.\nTest caseA test case is a set of conditions or variables under which a tester will determine whether a system under test satisfies requirements or works correctly.\nTest OracleA test oracle is a mechanism that determines whether software executed correctly for a test case. We define a test oracle to contain two essential parts: oracle information that represents expected output; and an oracle procedure that compares the oracle information with the actual output.\n","categories":["软件测试"]},{"title":"String StringBuffer和StringBuilder","url":"/2021/01/20/String-StringBuffer%E5%92%8CStringBuilder/","content":"本篇详细的介绍了Java中String、StringBuffer和StringBuilder的区别\n\nStringString创建对象的两种方式\n通过new创建的字符串对象，每一次new都会申请一个内存空间，不管内容是否相同，每次申请的内存空间地址值都是不同的\n以””直接赋值的方式创建的字符串对象，是在常量池中维护的。在通过这种方式创建字符串对象时，JVM会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用，如果没有就在常量池中重新创建一个 String 对象\n\n如果对字符串进行拼接操作，每次拼接都会创建一个新的String对象，然后将引用指向新的 String 对象，这种不可避免的操作既耗时又浪费内存空间，Java提供的StringBuilder类可以解决这个问题\nString是不可变的String的不可变是什么意思？  不可变是指，若存在一个字符串”hello”，第二次给它赋值成“helloworld”，此时是在内存中新建了一个对象，并将引用变量指向新对象地址，原对象中的内容仍然是”hello”，String一旦赋值即不可变\n为什么String是不可变的？public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;    /** The value is used for character storage. */    private final char value[];\n观察String的源码，String类是用final关键字修饰的，这说明String不可继承。然后private final char value[]可见String 类中使用 final 关键字修饰字符数组来保存字符串，这说明String是不可变的\n\n在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte[] value;\n\n关于String不可变的小问题public static void main(String[] args) &#123;    String str = &quot;Hello&quot;;    str = str + &quot;World&quot;;    System.out.println(str);&#125;\n上述代码，执行结果是HelloWorld，发现String的值发生了改变。那么，问题出在哪？\n利用反编译分析的结果，在使用+进行字符串的拼接的时候，实际上jvm是初始化了一个StringBuilder进行拼接的\n相当于实际执行的代码段如下：\npublic static void main(String[] args) &#123;    String str = &quot;Hello&quot;;    //str = str + &quot;World&quot;;    StringBuilder stringBuilder = new StringBuilder();    stringBuilder.append(str).append(&quot;World&quot;);    str = stringBuilder.toString();    System.out.println(str);&#125;\n再延伸一个问题，观察下列代码段，判断程序输出结果\npublic static void main(String[] args) &#123;    String str = null;    str = str + &quot;&quot;;    System.out.println(str);&#125;\n答案是输出null。因为+实际上是调用StringBuilder的append()方法\n再分析一下StringBuilder中append()方法的源码\n@Overridepublic StringBuilder append(String str) &#123;    super.append(str);    return this;&#125;\n再定位到父类的append()方法\npublic AbstractStringBuilder append(String str) &#123;    if (str == null)        return appendNull();    int len = str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count += len;    return this;&#125;\n再查看appendNull()方法\nprivate AbstractStringBuilder appendNull() &#123;    int c = count;    ensureCapacityInternal(c + 4);    final char[] value = this.value;    value[c++] = &#x27;n&#x27;;    value[c++] = &#x27;u&#x27;;    value[c++] = &#x27;l&#x27;;    value[c++] = &#x27;l&#x27;;    count = c;    return this;&#125;\n所以，如果传入的字符串是null时，调用appendNull()方法，返回null\nStringBuffer常用方法public static void main(String[] args) &#123;    //无参构造，创建一个空的StringBuffer对象    StringBuffer stringBuffer = new StringBuffer();    System.out.println(&quot;StringBuffer:&quot; + stringBuffer);    //获取长度    System.out.println(&quot;StringBuffer的长度:&quot; + stringBuffer.length());    //有参构造    stringBuffer = new StringBuffer(&quot;Hello World&quot;);    System.out.println(&quot;StringBuffer:&quot; + stringBuffer);    //根据索引取值    System.out.println(&quot;下标为2的字符是：&quot; + stringBuffer.charAt(2));    //添加：append()    stringBuffer = stringBuffer.append(&quot; Java&quot;);    System.out.println(&quot;append之后的StringBuffer：&quot; + stringBuffer);    //删除指定区间内的字符：delete(int start, int end)    stringBuffer = stringBuffer.delete(6, 12);    System.out.println(&quot;delete之后的StringBuffer：&quot; + stringBuffer);    //删除指定索引位置处的字符：deleteCharAt(int index)    stringBuffer = stringBuffer.deleteCharAt(3);    System.out.println(&quot;deleteCharAt之后的StringBuffer：&quot; + stringBuffer);    //将指定区间内的值替换：replace(int start, int end, String str)    stringBuffer = stringBuffer.replace(0, 4, &quot;StringBuffer&quot;);    System.out.println(&quot;replace之后的StringBuffer：&quot; + stringBuffer);    //截取字符串（从指定位置到结尾）：substring(int start)    String str = stringBuffer.substring(6);    System.out.println(&quot;substring之后的String：&quot; + str);    //截取字符串（从指定位置到指定位置）：substring(int start, int end)    str = stringBuffer.substring(0, 12);    System.out.println(&quot;substring之后的String：&quot; + str);    //向指定位置插入：insert(int offset, String str)    stringBuffer = stringBuffer.insert(0, &quot;Hello &quot;);    System.out.println(&quot;insert之后的StringBuffer：&quot; + stringBuffer);    //从头开始查找指定字符的索引位置：indexOf(String str)    System.out.println(&quot;Java的下标是：&quot; + stringBuffer.indexOf(&quot;Java&quot;));    //从指定位置开始查找指定字符的索引位置：indexOf(String str, int fromIndex)    System.out.println(&quot;下标21之后的a的下标是：&quot; + stringBuffer.indexOf(&quot;a&quot;, 21));    //字符串反转：reverse()    stringBuffer = stringBuffer.reverse();    System.out.println(&quot;reverse之后的StringBuffer：&quot; + stringBuffer);    //返回StringBuffer对应的String：toString()    str = stringBuffer.toString();    System.out.println(&quot;StringBuffer对应的String：&quot; + str);&#125;\n源码分析public final class StringBuffer   extends AbstractStringBuilder   implements java.io.Serializable, CharSequence\nStringBuffer类继承自AbstractStringBuilder类\nabstract class AbstractStringBuilder implements Appendable, CharSequence &#123;    /**     * The value is used for character storage.     */    char[] value;\nAbstractStringBuilder类底层实现中也是使用字符数组保存字符串，且该字符数组没有用final关键字修饰，所以内容是可变的\n/** * Constructs a string buffer with no characters in it and an * initial capacity of 16 characters. */public StringBuffer() &#123;    super(16);&#125;\nStringBuffer底层用数组来存储字符串的值，并且数组的默认长度是16。实例化一个空的StringBuffer对象即创建了一个大小为16个字符的字符串缓冲区\n/** * Constructs a string buffer initialized to the contents of the * specified string. The initial capacity of the string buffer is * &#123;@code 16&#125; plus the length of the string argument. * * @param   str   the initial contents of the buffer. */public StringBuffer(String str) &#123;    super(str.length() + 16);    append(str);&#125;\n当调用带参构造创建StringBuffer对象时，字符数组的长度为传入的参数的长度+16。根据源码，super(str.length() + 16);创建一个长度为str长度+16的字符串缓冲区，append(str);将str添加到字符串数组中。这意味着一个StringBuffer对象创建完成后，可以有16个字符的缓冲空间以供对其值进行修改。\n那么如果修改的值范围超过了16呢？\n@Overridepublic synchronized void ensureCapacity(int minimumCapacity) &#123;    super.ensureCapacity(minimumCapacity);&#125;\npublic void ensureCapacity(int minimumCapacity) &#123;    if (minimumCapacity &gt; 0)        ensureCapacityInternal(minimumCapacity);&#125;\n/** * For positive values of &#123;@code minimumCapacity&#125;, this method * behaves like &#123;@code ensureCapacity&#125;, however it is never * synchronized. * If &#123;@code minimumCapacity&#125; is non positive due to numeric * overflow, this method throws &#123;@code OutOfMemoryError&#125;. */private void ensureCapacityInternal(int minimumCapacity) &#123;    // overflow-conscious code    if (minimumCapacity - value.length &gt; 0) &#123;        value = Arrays.copyOf(value,                newCapacity(minimumCapacity));    &#125;&#125;\n发现，如果修改的值超过了缓冲区的容量，会调用ensureCapacityInternal()方法来检查StringBuffer对象的原char数组长度能否满足要求，如果不能，则对数组进行扩容。扩容完成后调用Arrays.copyOf()方法完成数据的拷贝，Arrays.copyOf()底层是调用System.arryCopy()，将原数组内容拷贝到新数组，然后将引用指向新的数组\n扩容的逻辑/** * Returns a capacity at least as large as the given minimum capacity. * Returns the current capacity increased by the same amount + 2 if * that suffices. * Will not return a capacity greater than &#123;@code MAX_ARRAY_SIZE&#125; * unless the given minimum capacity is greater than that. * * @param  minCapacity the desired minimum capacity * @throws OutOfMemoryError if minCapacity is less than zero or *         greater than Integer.MAX_VALUE */private int newCapacity(int minCapacity) &#123;    // overflow-conscious code    int newCapacity = (value.length &lt;&lt; 1) + 2;    if (newCapacity - minCapacity &lt; 0) &#123;        newCapacity = minCapacity;    &#125;    return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0)        ? hugeCapacity(minCapacity)        : newCapacity;&#125;private int hugeCapacity(int minCapacity) &#123;    if (Integer.MAX_VALUE - minCapacity &lt; 0) &#123; // overflow        throw new OutOfMemoryError();    &#125;    return (minCapacity &gt; MAX_ARRAY_SIZE)        ? minCapacity : MAX_ARRAY_SIZE;&#125;\n从源码和注释我们能看出，扩容的逻辑实际上是：\n\n将现有的容量*2+2\n\n关于为什么扩容是两倍+2？\n\n旧版本的JDK，扩容语句是 (value.length + 1) * 2 先加一再乘2，推测原意思是扩容的话至少增添一个空间再乘2，兼顾到扩容的次数和要减少扩容过大浪费的空间\nnewCapacity(int)的传入参数有可能是0，0&lt;&lt;1结果还是0，如果没有+2，在数组初始化的时候就会报错，所以考虑到设计的安全性，防止出现报错，选择了+2\n\n\n\n再判断这个扩容后的容量是否满足要求，如果还是不满足，就直接扩大到需要的容量\n\n然后还需要对扩容后的新数组大小进行检查，若新数组大于Interger.MAX_VALUE，则报OutOfMemoryError()异常\n\n\n线程安全性StringBuffer对所有实现的方法几乎都添加了 synchronized 关键字修饰，实现了同步，保证了数据同步和线程安全\n\n但是方法同步需要消耗一定的系统资源，所以 StringBuffer 虽然安全，但是效率不如 StringBuilder\n\nStringBuilderStringBuilder是一个可变的字符串类，可变是指StringBuilder对象中的内容可变\n\n常用方法public static void main(String[] args) &#123;    //无参构造    StringBuilder stringBuilder = new StringBuilder();    System.out.println(&quot;StringBuilder:&quot; + stringBuilder);    //获取长度    System.out.println(&quot;StringBuilder的长度:&quot; + stringBuilder.length());    //有参构造    stringBuilder = new StringBuilder(&quot;Hello World&quot;);    System.out.println(&quot;StringBuilder:&quot; + stringBuilder);    //根据索引取值    System.out.println(&quot;下标为2的字符是：&quot; + stringBuilder.charAt(2));    //添加：append()    stringBuilder = stringBuilder.append(&quot; Java&quot;);    System.out.println(&quot;append之后的StringBuilder：&quot; + stringBuilder);    //删除指定区间内的字符：delete(int start, int end)    stringBuilder = stringBuilder.delete(6, 12);    System.out.println(&quot;delete之后的StringBuilder：&quot; + stringBuilder);    //删除指定索引位置处的字符：deleteCharAt(int index)    stringBuilder = stringBuilder.deleteCharAt(3);    System.out.println(&quot;deleteCharAt之后的StringBuilder：&quot; + stringBuilder);    //将指定区间内的值替换：replace(int start, int end, String str)    stringBuilder = stringBuilder.replace(0, 4, &quot;StringBuilder&quot;);    System.out.println(&quot;replace之后的StringBuilder：&quot; + stringBuilder);    //截取字符串（从指定位置到结尾）：substring(int start)    String str = stringBuilder.substring(6);    System.out.println(&quot;substring之后的String：&quot; + str);    //截取字符串（从指定位置到指定位置）：substring(int start, int end)    str = stringBuilder.substring(0, 12);    System.out.println(&quot;substring之后的String：&quot; + str);    //向指定位置插入：insert(int offset, String str)    stringBuilder = stringBuilder.insert(0, &quot;Hello &quot;);    System.out.println(&quot;insert之后的StringBuilder：&quot; + stringBuilder);    //从头开始查找指定字符的索引位置：indexOf(String str)    System.out.println(&quot;Java的下标是：&quot; + stringBuilder.indexOf(&quot;Java&quot;));    //从指定位置开始查找指定字符的索引位置：indexOf(String str, int fromIndex)    System.out.println(&quot;下标8之后的a的下标是：&quot; + stringBuilder.indexOf(&quot;a&quot;, 8));    //字符串反转：reverse()    stringBuilder = stringBuilder.reverse();    System.out.println(&quot;reverse之后的StringBuilder：&quot; + stringBuilder);    //返回StringBuffer对应的String：toString()    str = stringBuilder.toString();    System.out.println(&quot;StringBuilder对应的String：&quot; + str);&#125;\n源码分析观察StringBuilder源码，发现StringBuiler与StringBuffer继承自同一个父类AbstractStringBuilder，实现的接口也是完全一样的。StringBuiler与StringBuffer最大的区别就是，StringBuffer对几乎所有的方法都添加了synchronized关键字修饰实现了同步，而StringBuiler没有实现同步，所以StringBuiler无法保证线程安全\n线程不安全public static void main(String[] args) &#123;    StringBuilder stringBuilder = new StringBuilder();    //开启10个线程    for (int i = 0; i &lt; 10; i++) &#123;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                //每个线程添加1000个字符&quot;a&quot;                for (int j = 0; j &lt; 1000; j++) &#123;                    stringBuilder.append(&quot;a&quot;);                &#125;            &#125;        &#125;).start();    &#125;    //若是线程安全，则执行完毕后stringBuilder的长度应该为10*1000=10000    try &#123;        Thread.sleep(100);        System.out.println(stringBuilder.length());    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;\n分析上述代码运行结果，具体讨论下关于StringBuilder的线程不安全性\n\n运行结果是，输出的长度是比10000小的，且多运行几次会发现，有可能会出现数组越界异常\n首先，分析为什么达不到10000？\npublic AbstractStringBuilder append(String str) &#123;    if (str == null)        return appendNull();    int len = str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count += len;    return this;&#125;\n观察append()的源码，count += len;这条语句在多线程同时访问时很可能会出现计数错误。比如count = 0，len = 1，两个线程同时执行到这一行，获取的 count 都是 0，执行的结果都是 1，所以最终 count 的值为 1，而不是 2。这就解释了为什么最终的结果达不到预期大小的原因。\n然后，为什么会出现数组越界异常呢？\n字符的添加是通过调用putStringAt(count,str)方法完成的，count 为当前字符串的长度，通过 ensureCapacityinternal(count+len)方法对数组进行扩容之后，它一定是小于等于数组最大容量的，putStringAt(count,str)方法中每添加一个字符，都会给 count 加 1，当到达数组长度上限之后再进行扩容\n但是如果是两个线程同时执行putStringAt(count,str)，假设此时的 count = 3，数组容量为 4，两个线程拿到的 count 都为 3，数组容量大于 count，所以并不会进行扩容，这就意味着只剩一个空间，要插入两个字符，线程 A 执行完毕，count 变为 4，已经占满了整个数组，所以线程 B 执行的时候，超出了数组的长度，抛出异常\n\n对比效率对比public static void main(String[] args) &#123;    //String    long startTime1 = System.currentTimeMillis();    String s1 = &quot;&quot;;    for (int i = 0; i &lt; 50000; i++) &#123;        s1 += i;    &#125;    long endTime1 = System.currentTimeMillis();    System.out.println(&quot;String类型操作耗时&quot; + (endTime1 - startTime1) + &quot;毫秒&quot;);    //StringBuffer    long startTime2 = System.currentTimeMillis();    StringBuffer s2 = new StringBuffer();    for (int i = 0; i &lt; 50000; i++) &#123;        s2.append(i);    &#125;    long endTime2 = System.currentTimeMillis();    System.out.println(&quot;StringBuffer类型操作耗时&quot; + (endTime2 - startTime2) + &quot;毫秒&quot;);    System.out.println(&quot;========================================================&quot;);    //StringBuffer    long startTime3 = System.currentTimeMillis();    StringBuffer s3 = new StringBuffer();    for (int i = 0; i &lt; 5000000; i++) &#123;        s3.append(i);    &#125;    long endTime3 = System.currentTimeMillis();    System.out.println(&quot;StringBuffer类型操作耗时&quot; + (endTime3 - startTime3) + &quot;毫秒&quot;);    //StringBuilder    long startTime4 = System.currentTimeMillis();    StringBuilder s4 = new StringBuilder();    for (int i = 0; i &lt; 5000000; i++) &#123;        s4.append(i);    &#125;    long endTime4 = System.currentTimeMillis();    System.out.println(&quot;StringBuilder类型操作耗时&quot; + (endTime4 - startTime4) + &quot;毫秒&quot;);&#125;\n\n从测试结果来看，对字符串进行大量次数的拼接操作，StringBuffer比String的耗时要小得多。但是同时对比StringBuffer与StringBuilder的操作耗时，由于StringBuffer线程同步需要消耗一定的系统资源，所以效率不如StringBuilder，但是StringBuffer比StringBuilder更安全\nStringBuilder 的效率一定就比 String 更高吗？会存在这个问题，就说明答案显然是不一定(￣▽￣)”\nString str = &quot;Hello&quot;+&quot;World&quot;;StringBuilder stringBuilder = new StringBuilder(&quot;Hello&quot;);stringBuilder.append(&quot;World&quot;);\n上面这种情况下，直接使用String创建对象的效率更高\n因为String对象的直接拼接，JVM会自动对其进行优化，也就是说”Hello”+”World”在编译期间会自动优化为”HelloWorld”，直接一次性创建完成，所以效率肯定要高于StringBuffer的append拼接\n但是要注意区分直接拼接和间接拼接\n直接拼接与间接拼接//直接拼接String str1 = &quot;Hello World&quot;;String str2 = &quot;Hello&quot; + &quot; World&quot;;System.out.println(str1 == str2);//true//间接拼接String str11 = &quot;Hello World&quot;;String str22 = &quot;Hello&quot;;String str33 = str22 + &quot; World&quot;;System.out.println(str11 == str33);//false\n分析：\n\n“Hello”+”World”在编译期间会被JVM自动优化成”Hello World”，是一个字符串常量，由于常量池中已存在”Hello World”，所以指向同一个对象\nstr2 + “ World” 对变量进行的间接拼接，JVM在编译期间不会自动优化，相当于新建了一个对象\n\n【补】代码分析public static void main(String[] args) &#123;    String str = &quot;Hello&quot;;    test(str);    System.out.println(str);    //输出：Hello&#125;public static void test(String str) &#123;    str += &quot;World&quot;;&#125;\n分析：String不可变，Java是值传递，方法内改变的只是副本（新对象）\npublic static void main(String[] args) &#123;    StringBuffer str = new StringBuffer(&quot;Hello&quot;);    test(str);    System.out.println(str);    //输出：Hello World&#125;public static void test(StringBuffer str) &#123;    str.append(&quot; World&quot;);&#125;\n分析：StringBuffer可变，且append()源码中是return this;，即是在当前对象后面追加元素并返回当前对象\n总结\n可变与不可变\n\n\nString 不可变\n\nStringBuffer 和 StringBuilder 可变\n\n\n\n线程是否安全\n\nString 和 StringBuffer 线程安全\n\nStringBuilder 线程不安全\n\n\n\n是否重写 equals() 和 hashCode() 方法\n\n\n\nString 重写了 equals() 和 hashCode() 方法\nStringBuffer 和 StringBuilder 没有重写 equals() 和 hashCode() 方法\n\n\n\n使用场景当需要对字符串对象进行频繁的修改时，使用 StringBuffer 可以极大提升程序的效率。在需要考虑线程安全的场景下我们可以使用  StringBuffer ，不需要考虑线程安全，追求更高效率的场景下可以使用 StringBuilder\nReferenceshttps://mp.weixin.qq.com/s/dltB1Fzwdezs4PDN8Thx6w\nhttps://www.cnblogs.com/DMingO/p/13407303.html\n","categories":["Java"],"tags":["Java"]},{"title":"Java基础","url":"/2021/01/06/Java%E5%9F%BA%E7%A1%80/","content":"本篇较系统地整理一下Java语言的基础知识点\n\n安装Java开发环境一、JDK下载安装\n官网下载jdk8\n二、环境变量的配置\n\n\n\n\n变量名\n变量值\n\n\n\n\nJAVA_HOME\nD:\\JAVA\\jdk1.8.0_172(自己的jdk安装路径)\n\n\nJRE_HOME\n%JAVA_HOME%\\jre\n\n\nCLASSPATH\n.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n\n\nPATH\n%JAVA_HOME%\\bin\n\n\nPATH\n%JAVA_HOME%\\jre\\bin\n\n\n\n\n三、检验是否配置成功\ncmd输入java -version，出现相关配置信息则配置成功。\n编译型语言和解释型语言计算机是不能直接执行高级语言的，需要将高级语言转换成机器码才能够被计算机理解执行。\n高级语言转换成机器码的方式有两种：\n\n编译\n只需编译一次即可将源代码编译成机器语言，以后要再运行时，直接使用编译结果即可，故编译型语言执行效率高\n由于执行速度快，多用于开发操作系统等，但是跨平台性差\n编译型语言代表：C、C++、Pascal/Object Pascal（Delphi）等\n\n\n解释\n源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。不需要事先编译，代码在执行时才被解释器动态翻译和执行，每执行一次都要翻译一次\n运行效率相对比较低，跨平台性好。多用于网页脚本、服务器脚本及辅助开发接口等对速度要求不高，对不同系统平台间的兼容性有一定要求的程序\n解释性语言代表：Python、JavaScript、Shell、Ruby、MATLAB等\n\n\n\nJava可以说既是编译型语言，也是解释型语言，因为它同时具备编译性和解释性。\n\njava文件先编译成与平台无关的.class的字节码文件，然后.class的字节码文件既可以在Windows平台上的java虚拟机（JVM）上进行解释运行，也可以在Linux平台上的JVM上解释运行；而JVM的翻译过程时解释性的，JVM从.class的字节码文件中读出一条指令，翻译一条指令，然后执行一条指令，这个过程就称为java的解释执行；\n\nJava数据类型基本类型\n数值类型\n\n整数类型：byte、short、int、long\n\n浮点类型：float、double\n\n字符类型：char（注意：char在Java中占用两个字节）\n\n字符封装类 Character 有一个成员常量 Character.SIZE 值为 16，单位是bits，该值除以 8(1byte=8bits)后就可以得到 2 个字节\n\n\n\n\nboolean类型\n\n\n\n\n\n\n基本类型\n包装类\n位数\n字节\n默认值\n\n\n\n\nint\nInteger\n32\n4\n0\n\n\nshort\nShort\n16\n2\n0\n\n\nlong\nLong\n64\n8\n0L\n\n\nbyte\nByte\n8\n1\n0\n\n\nchar\nCharacter\n16\n2\n‘u0000’\n\n\nfloat\nFloat\n32\n4\n0f\n\n\ndouble\nDouble\n64\n8\n0d\n\n\nboolean\nBoolean\n1\n\nfalse\n\n\n\n\n注意：\n\nJava中使用long类型的数据一定要在数值后面加上L，否则将作为整型解析\n对于 boolean的字节长度，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素\n\n引用类型\n类（String是一个类，属于引用数据类型）\n接口\n数组\n\n类型转换容量（小 —&gt; 大）：byte &lt; short = char &lt; int &lt; long &lt; float &lt; double\n\n除布尔型以外的其它七种类型都可相互转换\n小容量向大容量类型转换，为自动转换\n大容量向小容量类型转换，为强制转换，但是会损失精度\n\n装箱与拆箱在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：\n  Integer i = new Integer(10);\n从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：\n  Integer i = 10;\n\n装箱：将基本类型用它们对应的引用类型包装起来\n\nInteger i = 10;  //装箱\n\n拆箱：将包装类型转换为基本数据类型\n\nint n = i;   //拆箱\n看上去挺简单，实则不然。更多内容待补充…\nJava常见关键字\n\n\n\n访问控制\nprivate\nprotected\npublic\n\n\n\n\n\n\n\n\n类，方法和变量修饰符\nabstract\nclass\nextends\nfinal\nimplements\ninterface\nnative\n\n\n\nnew\nstatic\nstrictfp\nsynchronized\ntransient\nvolatile\n\n\n\n程序控制\nbreak\ncontinue\nreturn\ndo\nwhile\nif\nelse\n\n\n\nfor\ninstanceof\nswitch\ncase\ndefault\n\n\n\n\n错误处理\ntry\ncatch\nthrow\nthrows\nfinally\n\n\n\n\n包相关\nimport\npackage\n\n\n\n\n\n\n\n基本类型\nboolean\nbyte\nchar\ndouble\nfloat\nint\nlong\n\n\n\nshort\nnull\ntrue\nfalse\n\n\n\n\n\n变量引用\nsuper\nthis\nvoid\n\n\n\n\n\n\n保留字\ngoto\nconst\n\n\n\n\n\n\n\n\nJava变量作用域在Java中，变量的作用域分为四个级别：\n\n类级\n\n类级变量又称全局级变量或静态变量，需要使用static关键字修饰。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。\n\n\n对象实例级\n\n对象实例级变量就是成员变量，实例化后才会分配内存空间，才能访问。成员变量是定义在方法之外，类之内的。成员变量随着对象的创建而存在，随着对象的消失而消失。\n\n\n方法级\n\n方法级变量就是在方法内部定义的变量，就是局部变量。局部变量在调用了对应的方法时执行到了创建该变量的语句时存在，局部变量的作用域从它被声明的点开始，一旦出了自己的作用域马上从内存中消失。\n\n\n块级\n\n块级变量就是定义在一个块内部的变量，变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。块是指由大括号包围的代码\n\n\n\n补充点：\n\n类级变量和成员变量是有默认的初始值\n方法级和块级的变量没有默认的初始值，必须被显示地初始化，否则不能访问\n\npublic class VariableScope &#123;    public static String name = &quot;Class-level variables&quot;; // 类级变量,static修饰    public int i; // 对象实例级变量    // 属性块，在类初始化属性时候运行    &#123;        int j = 2;// 块级变量    &#125;    public void methodTest() &#123;        int j = 3; // 方法级变量        if (j == 3) &#123;            int k = 5; // 块级变量        &#125;        System.out.println(&quot;name=&quot; + name + &quot;, i=&quot; + i + &quot;, j=&quot; + j);        // 这里不能访问块级变量，块级变量只能在块内部访问        //System.out.println(&quot;k=&quot;+k);    &#125;    public static void main(String[] args) &#123;        // 不创建对象，直接通过类名访问类级变量        System.out.println(VariableScope.name);        // 创建对象并访问它的方法        VariableScope v = new VariableScope();        v.methodTest();    &#125;&#125;\nJava注释与JavaDocJava中的注释：\n\n单行注释//\n多行注释/*…*/\n文档注释/**…*/\n\njavadoc是Sun公司提供的一个技术，它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档\n常用参数：\n\n@author     作者名\n@version    版本号\n@since        API在什么程序的什么版本后开发支持\n@param     参数名\n@return     对函数返回值的注释\n@throws    异常抛出情况\n\n通过DOS命令执行生成javadoc文档：\n#Doc.java为需要生成javadoc文档的程序名javadoc -encoding UTF-8 -charset UTF-8 Doc.java\nJava可变参数java可变参数是1.5版本之后的新特性。可变参数用类型...定义，可变参数相当于数组类型\n\n可变参数本质就是动态创建的数组\n一个方法可以有可变参数和普通参数，但是可变参数必须放到参数列表末尾\n一个方法有且只能有一个可变参数\n\nclass Group &#123;    private String[] names;    public void setNames(String... names) &#123;        this.names = names;    &#125;&#125;\n上面的setNames()就定义了一个可变参数。调用时，可以这么写：\nGroup g = new Group();g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); // 传入3个Stringg.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); // 传入2个Stringg.setNames(&quot;Xiao Ming&quot;); // 传入1个Stringg.setNames(); // 传入0个String\n完全可以把可变参数改写为String[]类型：\nclass Group &#123;    private String[] names;    public void setNames(String[] names) &#123;        this.names = names;    &#125;&#125;\n但是，调用方需要自己先构造String[]，比较麻烦。例如：\nGroup g = new Group();g.setNames(new String[] &#123;&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;&#125;); // 传入1个String[]\n另一个问题是，调用方可以传入null：\nGroup g = new Group();g.setNames(null);\n而可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。\n参数绑定调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定\n基本类型参数绑定public class Main &#123;    public static void main(String[] args) &#123;        Person p = new Person();        int n = 15; // n的值为15        p.setAge(n); // 传入n的值        System.out.println(p.getAge()); // 15        n = 20; // n的值改为20        System.out.println(p.getAge()); // 15还是20?    &#125;&#125;class Person &#123;    private int age;    public int getAge() &#123;        return this.age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n输出结果：\n1515\n分析：\n修改外部的局部变量n，不影响实例p的age字段，原因是setAge()方法获得的参数，复制了n的值，因此，p.age和局部变量n互不影响\n结论：\n基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响\n引用类型参数绑定public class Main &#123;    public static void main(String[] args) &#123;        Person p = new Person();        String[] fullname = new String[] &#123; &quot;Homer&quot;, &quot;Simpson&quot; &#125;;        p.setName(fullname); // 传入fullname数组        System.out.println(p.getName()); // &quot;Homer Simpson&quot;        fullname[0] = &quot;Bart&quot;; // fullname数组的第一个元素修改为&quot;Bart&quot;        System.out.println(p.getName()); // &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;?    &#125;&#125;class Person &#123;    private String[] name;    public String getName() &#123;        return this.name[0] + &quot; &quot; + this.name[1];    &#125;    public void setName(String[] name) &#123;        this.name = name;    &#125;&#125;\n输出结果：\nHomer SimpsonBart Simpson\n分析：\nsetName()的参数现在是一个数组。一开始，把fullname数组传进去，然后，修改fullname数组的内容，结果发现，实例p的字段p.name也被修改了\n结论：\n引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方\n对比分析另一个引用类型的参数绑定\npublic class Main &#123;    public static void main(String[] args) &#123;        Person p = new Person();        String bob = &quot;Bob&quot;;        p.setName(bob); // 传入bob变量        System.out.println(p.getName()); // &quot;Bob&quot;        bob = &quot;Alice&quot;; // bob改名为Alice        System.out.println(p.getName()); // &quot;Bob&quot;还是&quot;Alice&quot;?    &#125;&#125;class Person &#123;    private String name;    public String getName() &#123;        return this.name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n输出结果：\nBobBob\n分析：\nString的值是不可变的 ，对String 重新赋值的时候，会重新创建一个bob的引用。当 bob = “Alice”时，会在内存中新开辟一个空间，bob的指向变了。但是name属性还是指向原来的内存空间，还是Bob\n构造方法调用构造方法，必须用new操作符\n默认构造方法如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法\nclass Person &#123;    public Person() &#123;    &#125;&#125;\n注意：如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法。此时要使用默认构造方法，必须在代码中显式的定义出来\npublic class Main &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(&quot;Xiao Ming&quot;, 15); // 既可以调用带参数的构造方法        Person p2 = new Person(); // 也可以调用无参数构造方法    &#125;&#125;class Person &#123;    private String name;    private int age;    public Person() &#123;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;        public String getName() &#123;        return this.name;    &#125;    public int getAge() &#123;        return this.age;    &#125;&#125;\n既对字段进行初始化，又在构造方法中对字段进行初始化：\nclass Person &#123;    private String name = &quot;Unamed&quot;;    private int age = 10;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;\n在Java中，创建对象实例的时候，按照如下顺序进行初始化：\n\n先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；\n执行构造方法的代码进行初始化。\n\n因此，构造方法的代码由于后运行，所以，new Person(&quot;Xiao Ming&quot;, 12)的字段值最终由构造方法的代码确定\n多构造方法class Person &#123;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Person(String name) &#123;        this.name = name;        this.age = 12;    &#125;    public Person() &#123;    &#125;&#125;\n如果调用new Person(&quot;Xiao Ming&quot;, 20);，会自动匹配到构造方法public Person(String, int)。\n如果调用new Person(&quot;Xiao Ming&quot;);，会自动匹配到构造方法public Person(String)。\n如果调用new Person();，会自动匹配到构造方法public Person()。\n一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)\nclass Person &#123;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Person(String name) &#123;        this(name, 18); // 调用另一个构造方法Person(String, int)    &#125;    public Person() &#123;        this(&quot;Unnamed&quot;); // 调用另一个构造方法Person(String)    &#125;&#125;\n重载与重写重载在同一个类中，不同的函数使用相同的函数名，但是函数的形参个数或类型不同\n实现理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等逐个匹配，以选择对应的方法，若匹配失败，则编译器报错\n注意点：\n\n方法的返回类型可以相同，也可以不同\n重载的方法必须拥有不同的参数列表，而不能仅仅依据修饰符或者返回类型的不同来重载方法\n\n重写子类继承父类的相同方法，但要实现的功能与父类的方法不同，此时需要覆盖父类方法\n注意点：\n\n返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类\n（方法名相同，方法参数相同，但方法返回值不同，也是不同的方法）\n\n如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明\n\n构造方法无法被重写\n\n\nOOP的三大特征封装把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息\n封装的优点：\n\n良好的封装能够减少耦合\n\n类内部的结构可以自由修改\n\n可以对成员变量进行更精确的控制\n\n隐藏信息，实现细节\n\n\nJavaBeanIDEA快捷键：Alt+Insert\nclass Person &#123;    private String name;    private int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n继承Java使用extends关键字来实现继承。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。\npublic class Student extends Person &#123;    private int score;    public int getScore() &#123;        return score;    &#125;    public void setScore(int score) &#123;        this.score = score;    &#125;&#125;\n我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）\n在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类\n【特点】\n\n子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是子类无法访问父类中的私有属性和方法\n\n用protected修饰的字段可以被子类访问，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问\n\n\n子类可以拥有自己属性和方法，即子类可以对父类进行扩展\n\n子类可以用自己的方式实现父类的方法\n\n\n构造方法的继承在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();\n如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法\n子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的\n阻止继承正常情况下，只要某个class没有final修饰符，那么任何类都可以从该class继承\n从Java 15开始，允许使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称\n例如，定义一个Shape类：\npublic sealed class Shape permits Rect, Circle, Triangle &#123;    ...&#125;\n上述Shape类就是一个sealed类，它只允许指定的3个类继承它。如果写：\npublic final class Rect extends Shape &#123;...&#125;\n是没问题的，因为Rect出现在Shape的permits列表中。但是，如果定义一个Ellipse就会报错：\npublic final class Ellipse extends Shape &#123;...&#125;&#x2F;&#x2F; Compile error: class is not allowed to extend sealed class: Shape\n原因是Ellipse并未出现在Shape的permits列表中。这种sealed类主要用于一些框架，防止继承被滥用\nsealed类在Java 15中目前是预览状态，要启用它，必须使用参数--enable-preview和--source 15\n向上转型(upcasting)子类引用的对象转换为父类类型称为向上转型\nStudent s = new Student();Person p = s; // upcasting, okObject o1 = p; // upcasting, okObject o2 = s; // upcasting, ok\n分析：\n因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的\n向下转型(downcasting)父类引用的对象转换为子类类型\nPerson p1 = new Student(); // upcasting, okPerson p2 = new Person();Student s1 = (Student) p1; // okStudent s2 = (Student) p2; // runtime error! ClassCastException!\n分析：\nPerson类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来\ninstanceof操作符\n判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false\n\nPerson p = new Person();System.out.println(p instanceof Person); // trueSystem.out.println(p instanceof Student); // falseStudent s = new Student();System.out.println(s instanceof Person); // trueSystem.out.println(s instanceof Student); // trueStudent n = null;System.out.println(n instanceof Student); // false\n为了避免向下转型出错，可以使用instanceof操作符\nPerson p = new Student();if (p instanceof Student) &#123;    // 只有判断成功才会向下转型:    Student s = (Student) p; // 一定会成功&#125;\n从Java 14开始，判断instanceof后，可以直接转型为指定变量，避免再次强制转型\nObject obj = &quot;hello&quot;;if (obj instanceof String) &#123;    String s = (String) obj;    System.out.println(s.toUpperCase());&#125;\n上述代码与如下代码等效：\nObject obj = &quot;hello&quot;;if (obj instanceof String s) &#123;    // 可以直接使用变量s:    System.out.println(s.toUpperCase());&#125;\n多态概念理解事物在运行过程中存在不同的状态，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法\n同一个接口，使用不同的实例而执行不同操作\n实现多态的前提\n存在继承关系\n子类重写父类的方法\n父类引用指向子类对象（Parent p = new Student();）\n\n例子public class PolymorphicTest &#123;    public static void main(String[] args) &#123;        show(new Cat());  // 以 Cat 对象调用 show 方法        show(new Dog());  // 以 Dog 对象调用 show 方法        Animal a = new Cat();  // 向上转型        a.eat();               // 调用的是 Cat 的 eat        Cat c = (Cat) a;        // 向下转型        c.work();        // 调用的是 Cat 的 work    &#125;    public static void show(Animal a) &#123;        a.eat();        // 类型判断        if (a instanceof Cat) &#123;  // 猫做的事情            Cat c = (Cat) a;            c.work();        &#125; else if (a instanceof Dog) &#123; // 狗做的事情            Dog c = (Dog) a;            c.work();        &#125;    &#125;&#125;abstract class Animal &#123;    abstract void eat();&#125;class Cat extends Animal &#123;    public void eat() &#123;        System.out.println(&quot;吃鱼&quot;);    &#125;    public void work() &#123;        System.out.println(&quot;抓老鼠&quot;);    &#125;&#125;class Dog extends Animal &#123;    public void eat() &#123;        System.out.println(&quot;吃骨头&quot;);    &#125;    public void work() &#123;        System.out.println(&quot;看家&quot;);    &#125;&#125;\n抽象类abstract class Person &#123;    public abstract void run();&#125;\n如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰\n因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）\nabstract修饰的类称为抽象类，抽象类无法被实例化\n抽象类本身被设计成只能用于被继承，因此抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此抽象方法实际上相当于定义了一种“规范”\n面向抽象编程\n当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例：\nPerson s = new Student();Person t = new Teacher();\n这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型：\n// 不关心Person变量的具体子类型:s.run();t.run();\n这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程\n面向抽象编程的本质就是：\n\n上层代码只定义规范（例如：abstract class Person）；\n不需要子类就可以实现业务逻辑（正常编译）；\n具体的业务逻辑由不同的子类实现，调用者并不关心。\n\n接口interface Person &#123;    void run();    String getName();&#125;\n接口是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。可以理解为，接口是抽象类的进一步抽象。\n接口特性\n接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）\n接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）\n接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法\n一个类可以实现多个接口\n一个接口可以继承自另一个接口\n接口无法被实例化，但是可以被实现(implements)。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类\n\n接口与类的区别\n接口不能用于实例化对象\n接口没有构造方法\n接口中所有的方法必须是抽象方法\n接口不能包含成员变量，除了 static 和 final 变量\n接口不是被类继承了，而是要被类实现\n\n接口与抽象类的区别\n抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行\n抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的\n一个类只能继承一个抽象类，而一个类却可以实现多个接口\n从设计的本质上去理解：抽象类是对象的抽象，而接口是一种行为规范\n\n进一步的思考：既然有了接口，为什么还需要抽象类？一个实现接口的类，必须实现接口中所描述的所有方法，而且接口中的方法不能有方法体，那么当多个类实现同一个接口时，如果存在相同的操作代码段，那么就必须在每个类中编写这部分相同的代码段，这就不符合代码重用的规则了。正确的做法是，将这段重复的操作代码段写在一个抽象类中，其他类继承自这个抽象类的同时，再实现接口，这样就做到了正确的封装。\nthis关键字和super关键字thisthis关键字用于引用类的当前实例\n如果没有命名冲突，可以省略this。例如：\nclass Person &#123;    private String name;    public String getName() &#123;        return name; // 相当于this.name    &#125;&#125;\n但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this：\nclass Person &#123;    private String name;    public void setName(String name) &#123;        this.name = name; // 前面的this不可少，少了就变成局部变量name了    &#125;&#125;\nsupersuper关键字表示父类，用于从子类访问父类的变量和方法\nclass Student extends Person &#123;    public String hello() &#123;        return &quot;Hello, &quot; + super.name;    &#125;&#125;\n详解static 和 final 和 static final区别staticstatic 是静态修饰关键字：可以修饰变量,程序块,方法,类\n\n修饰变量如果static修饰的是变量，则JVM会将其分配在内存堆上，该变量就与对象无关，所有对该变量的引用都指向同一个地址因此我们使用该变量的时候，直接指明类的静态变量，当然修饰符必须 public\npublic class StaticBean &#123;    public static String S = &quot;Hello World!&quot;;&#125;public static void main(String[] args) &#123;    System.out.println(StaticBean.S);&#125;\n\n修饰程序块JVM就会优先加载静态块中的代码，static 修饰代码块主要用于系统初始化\npublic class StaticBean &#123;    static &#123;        System.out.println(&quot;Static Block Code&quot;);    &#125;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;Main Block Code&quot;);    &#125;&#125;\n输出结果：\nStatic Block CodeMain Block Code\n\n修饰方法\n在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象，静态方法在访问本类的成员时，只允许访问静态成员，而不允许访问实例成员变量和实例方法\npublic class StaticBean &#123;    public static String S1 = &quot;Hello World!&quot;;    public String S2=&quot;S2&quot;;    public static void getMessage() &#123;        System.out.println(S1);        //下面这条语句是错的        //System.out.println(S2);    &#125;    //要访问实例成员变量S2，必须先创建一个对象    public static void main(String[] args) throws Exception &#123;        StaticBean staticBean = new StaticBean();        System.out.println(staticBean.S2);    &#125;&#125;\n总结：\n\nstatic类型的方法：只能调用static类型的属性，不能调用非static类型的属性\n非static类型的方法：既可以调用static类型的属性，也可以调用非static类型的属性\n\n\n修饰类\nstatic不能修饰普通类，它只能修饰内部类，称为静态内部类\n\n\n【补充用法】\n静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。\nfinalfinal 关键字可以用来修饰类，方法和变量，意思是最终的、不可修改的\n\n修饰类\n表示该类不允许被继承，final类中的成员方法都会被隐式的指定为final方法\n\n修饰方法表示该方法不能被重写，一个类的private方法会隐式的被指定为final方法\n\n修饰变量\n表示该变量必须初始化，且值不能改变。如果是基本类型则值不能改变，如果是引用类型，则引用地址不能改变，但是这个引用所指向的对象里面的内容还是可以改变的\n\n\nstatic finalstatic修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问\nstatic final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用\n内部类与静态内部类\n如果把类比喻成鸡蛋，内部类为蛋黄,外部类是蛋壳。那么静态类相当于熟鸡蛋，就算蛋壳破碎（外部类没有实例化），蛋黄依然完好（内部类可以实例化）；而非静态类相当于生鸡蛋，蛋壳破碎（无实例化），蛋黄也会跟着xx（不能实例化）\n\n内部类内部类是定义在另外一个类中的类\n\n内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据\n\n内部类可以对同一个包的其他类隐藏\n\n\n静态内部类和非静态内部类最大的区别是：非静态内部类编译后隐式保存着外部类的引用（就算外部类对象没用了也GC不掉），但是静态内部类没有\n/** * 外部类与内部类 * * @author LYX */public class OuterClass &#123;    private static final String S1 = &quot;A static final attribute of OuterClass.&quot;;    private String S2 = &quot;A general attribute of OuterClass.&quot;;    private static void outerStaticMethod() &#123;        System.out.println(&quot;This is a static method of OuterClass.&quot;);    &#125;    private void outerGeneralMethod() &#123;        System.out.println(&quot;This is a general method of OuterClass.&quot;);    &#125;    /**     * 内部类     */    public class InnerClass &#123;        private String S3;        public InnerClass(String S3) &#123;            this.S3 = S3;        &#125;        public void innerMethod() &#123;            System.out.println(S1);            System.out.println(S2);            System.out.println(S3);            outerStaticMethod();            outerGeneralMethod();        &#125;    &#125;    public static void main(String[] args) &#123;        OuterClass outerClass = new OuterClass();        InnerClass innerClass = outerClass.new InnerClass(&quot;A general attribute of InnerClass.&quot;);        innerClass.innerMethod();    &#125;&#125;\n运行结果：\nA static final attribute of OuterClass.A general attribute of OuterClass.A general attribute of InnerClass.This is a static method of OuterClass.This is a general method of OuterClass.\n结论：\n非静态内部类可以直接访问外部类的类变量、实例变量、类方法、实例方法。\n因为在非静态内部类对象中，保存了一个它所寄生的外部类对象的引用（非静态内部类实例必须寄生在外部类实例里）。即，非静态内部类对象总有一个隐式引用，指向创建它的外部类对象。\n注意：\n\n创建非静态内部类对象时，应该用外部类的实例对象名去new，因为非静态内部类依赖于其外部类\n\n Inner inner = outer.new Inner();\n\n\n外部类不能直接调用非静态内部类的成员，必须显示创建非静态内部类对象再调用\n\n根据静态成员不能访问非静态成员的规则，外部类的静态方法不能访问非静态内部类\n\n\n非静态内部类不允许定义静态成员\n\n\n\n非静态内部类方法访问某个变量的顺序为：\n\n方法中是否有该成员变量，有的话直接用该成员变量\n内部类中是否有该成员变量，有的话使用this.变量名\n外部类中是否有该成员变量，有的话使用外部类的类名.this.变量名\n\npublic class Outer &#123;    private int num = 1;    public class Inner &#123;        private int num = 2;        public void print() &#123;            int num = 3;            System.out.println(num);            System.out.println(this.num);            System.out.println(Outer.this.num);        &#125;    &#125;    public static void main(String[] args) &#123;        Outer outer = new Outer();        Inner inner = outer.new Inner();        inner.print();    &#125;&#125;\n运行结果：\n321\n静态内部类静态内部类是用static修饰的内部类。这个内部类属于外部类本身，但是不属于外部类的任何对象。\n\n静态内部类不能访问外部类的实例成员，只能访问外部类的类成员\n\n外部类可以使用静态内部类的类名作为调用者来访问静态内部类的类成员，也可以使用静态内部类对象访问其实例成员\n\n不持有外部类的引用（普通内部类持有）\n\n可以直接创建实例，不需要先创建外部类（普通内部类需要）\n\n可以有静态成员变量、方法（普通内部类不行）和非静态成员变量、方法\n\n只可以直接访问外部类静态成员，不可以直接访问外部类的非静态成员（普通内部类可以），需要通过传入外部类引用的方式才能访问\n\n加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生\n\n创建静态内部类时不需要依赖于其外部类，可直接new\n\nInner inner = new Inner();\n\n\n\npublic class OuterAndStaticInner &#123;    private String S1 = &quot;Outer S1&quot;;    private static String S2 = &quot;Outer Static S2&quot;;    public void print() &#123;        System.out.println(new StaticInnerClass().S3);        System.out.println(StaticInnerClass.S4);    &#125;    /**     * 静态内部类     */    static class StaticInnerClass &#123;        private String S3 = &quot;Inner S3&quot;;        private static String S4 = &quot;Inner Static S4&quot;;        public void print() &#123;            //无法直接调用S1            //System.out.println(S1);            System.out.println(S2);        &#125;    &#125;    public static void main(String[] args) &#123;        OuterAndStaticInner outerAndStaticInnerTest = new OuterAndStaticInner();        outerAndStaticInnerTest.print();        StaticInnerClass innerClass = new StaticInnerClass();        innerClass.print();    &#125;&#125;\n运行结果：\nInner S3Inner Static S4Outer Static S2\nReferences[1] https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\n[2] https://www.liaoxuefeng.com/wiki/1252599548343744\n[3] https://www.runoob.com/java/java-tutorial.html\n[4] https://www.cnblogs.com/HA-Tinker/p/10674226.html\n[5] https://www.cnblogs.com/GrimMjx/p/10105626.html\n","categories":["Java"],"tags":["Java"]}]